type EpochEdge {
  node: Epoch!
  cursor: String!
}

type EpochConnection {
  totalCount: Int!
  edges: [EpochEdge!]!
  nodes: [Epoch!]!
  pageInfo: PageInfo!
}

type Notice {
  id: ID!
  index: Int!
  sessionId: String!
  input: Input!
  keccak: String!
  "Payload in Ethereum hex binary format, starting with '0x'"
  payload: String!
}

type Input {
  id: ID!
  index: Int!
  epoch: Epoch!
  blockNumber: BigInt!
  """
    Get notices from this particular input
    with additional ability to filter and paginate them
  """
  notices(first: Int, last: Int, after: String, before: String): NoticeConnection!
}

scalar BigInt

type Query {
  epoch(id: ID!): Epoch!
  input(id: ID!): Input!
  notice(id: ID!): Notice!
  epochs(first: Int, last: Int, after: String, before: String): EpochConnection!
  inputs(first: Int, last: Int, after: String, before: String): InputConnection!
  notices(first: Int, last: Int, after: String, before: String): NoticeConnection!
}

type NoticeEdge {
  node: Notice!
  cursor: String!
}

type NoticeConnection {
  totalCount: Int!
  edges: [NoticeEdge!]!
  nodes: [Notice!]!
  pageInfo: PageInfo!
}

"Connection pattern cursor based pagination page info"
type PageInfo {
  startCursor: String!
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

type InputEdge {
  node: Input!
  cursor: String!
}

type Epoch {
  id: ID!
  index: Int!
  inputs(first: Int, last: Int, after: String, before: String): InputConnection!
}

type InputConnection {
  totalCount: Int!
  edges: [InputEdge!]!
  nodes: [Input!]!
  pageInfo: PageInfo!
}

schema {
  query: Query
}
