/* Copyright 2022 Cartesi Pte. Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

use diesel::pg::PgConnection;
use diesel::prelude::*;
use diesel::r2d2::{ConnectionManager, Pool};
use juniper_from_schema::graphql_schema_from_file;
use std::sync::Arc;
use tracing::debug;

// Generate Rust objects from current graphql schema
// To inspect generated code build with `JUNIPER_FROM_SCHEMA_DEBUG=1 cargo build`
graphql_schema_from_file!("../data/graphql/typeDefs.graphql");

use juniper::{Executor, FieldResult};

pub struct Context {
    // Connection is not thread safe to share between threads, we use connection pool
    pub db_pool: Arc<Pool<ConnectionManager<PgConnection>>>,
}
impl juniper::Context for Context {}

/// Graphql representation of the page info
pub struct PageInfo {
    pub has_next_page: bool,
}

impl PageInfoFields for PageInfo {
    fn field_has_next_page(
        &self,
        _executor: &Executor<Context>,
    ) -> FieldResult<&bool> {
        Ok(&self.has_next_page)
    }
}

/// Graphql representation of the notice edge
pub struct NoticeEdge {
    pub node: Notice,
    // Cursor is intentionally string although it is actually
    // autoincrement index in the database,
    // in case that we want to change its type/implementation
    pub cursor: String,
}

/// Necessary graphql boilerplate for NoticeEdge
impl NoticeEdgeFields for NoticeEdge {
    fn field_node(
        &self,
        _executor: &Executor<Context>,
        _trail: &QueryTrail<'_, Notice, Walked>,
    ) -> FieldResult<&Notice> {
        Ok(&self.node)
    }

    fn field_cursor(
        &self,
        _executor: &Executor<Context>,
    ) -> FieldResult<&String> {
        Ok(&self.cursor)
    }
}

/// Graphql representation of the notice connection
pub struct NoticeConnection {
    edges: Vec<NoticeEdge>,
    page_info: PageInfo,
}

/// Necessary graphql boilerplate for Notice
impl NoticeConnectionFields for NoticeConnection {
    fn field_edges(
        &self,
        _executor: &Executor<Context>,
        _trail: &QueryTrail<'_, NoticeEdge, Walked>,
    ) -> FieldResult<&Vec<NoticeEdge>> {
        Ok(&self.edges)
    }

    fn field_page_info(
        &self,
        _executor: &Executor<Context>,
        _trail: &QueryTrail<'_, PageInfo, Walked>,
    ) -> FieldResult<&PageInfo> {
        Ok(&self.page_info)
    }
}

/// Graphql representation of the Notice
pub struct Notice {
    session_id: String,
    epoch_index: i32,
    input_index: i32,
    notice_index: i32,
    keccak: String,
    payload: String,
}

/// Necessary graphql boilerplate for Notice
impl NoticeFields for Notice {
    fn field_session_id(
        &self,
        _executor: &Executor<Context>,
    ) -> FieldResult<&String> {
        Ok(&self.session_id)
    }

    fn field_epoch_index(
        &self,
        _executor: &Executor<Context>,
    ) -> FieldResult<&i32> {
        Ok(&self.epoch_index as &i32)
    }

    fn field_input_index(
        &self,
        _executor: &Executor<Context>,
    ) -> FieldResult<&i32> {
        Ok(&self.input_index)
    }

    fn field_notice_index(
        &self,
        _executor: &Executor<Context>,
    ) -> FieldResult<&i32> {
        Ok(&self.notice_index)
    }

    fn field_keccak(
        &self,
        _executor: &Executor<Context>,
    ) -> FieldResult<&String> {
        Ok(&self.keccak)
    }

    fn field_payload(
        &self,
        _executor: &Executor<Context>,
    ) -> FieldResult<&String> {
        Ok(&self.payload)
    }
}

/// Reader must implement QueryFields trait for Query struct
pub struct Query;

/// This trait is generated by `graphql_schema_from_file!` based on the schema
impl QueryFields for Query {
    /// Handle getNotice query
    fn field_get_notice(
        &self,
        executor: &juniper::Executor<Context>,
        _trail: &QueryTrail<'_, NoticeConnection, Walked>,
        notice_keys: std::option::Option<NoticeKeys>,
        first: std::option::Option<i32>,
        after: std::option::Option<String>,
    ) -> juniper::FieldResult<NoticeConnection> {
        use rollups_data::database::{schema::notices::dsl::*, DbNotice};
        // note: graphql does not have native Int64, so it is only 32 bit integer
        debug!("Query: notice keys: {:?}", notice_keys);

        let conn = executor.context().db_pool.get()?;
        // Form database selection command based on graphql query parameters
        let mut query = notices.into_boxed();
        let mut total_count_query = notices.into_boxed();
        if let Some(notice_keys) = notice_keys {
            if let Some(_session_id) = notice_keys.session_id {
                query = query.filter(session_id.eq(_session_id.clone()));
                total_count_query =
                    total_count_query.filter(session_id.eq(_session_id));
            };

            if let Some(index) = notice_keys.epoch_index {
                query = query.filter(epoch_index.eq(index as i32));
                total_count_query =
                    total_count_query.filter(epoch_index.eq(index as i32));
            };

            if let Some(index) = notice_keys.input_index {
                query = query.filter(input_index.eq(index as i32));
                total_count_query =
                    total_count_query.filter(input_index.eq(index as i32));
            };

            if let Some(index) = notice_keys.notice_index {
                query = query.filter(notice_index.eq(index as i32));
                total_count_query =
                    total_count_query.filter(notice_index.eq(index as i32));
            };
        }
        if let Some(first) = first {
            query = query.limit(first.into());
        };
        if let Some(after) = after {
            if let Ok(after_i32) = after.parse::<i32>() {
                query = query.filter(id.gt(after_i32));
            }
        };
        query = query.order_by(id.asc());
        // Retrieve data from database
        let result = query.load::<DbNotice>(&conn)?;

        let edges: Vec<NoticeEdge> = result
            .iter()
            .map(|db_notice| NoticeEdge {
                node: Notice {
                    session_id: db_notice.session_id.clone(),
                    epoch_index: db_notice.epoch_index as i32,
                    input_index: db_notice.input_index as i32,
                    notice_index: db_notice.notice_index as i32,
                    keccak: db_notice.keccak.clone(),
                    payload: "0x".to_string()
                        + hex::encode(
                            db_notice.payload.as_ref().unwrap_or(&Vec::new()),
                        )
                        .as_str(),
                },
                cursor: db_notice.id.to_string(),
            })
            .collect();

        // Deduce hasNextPage indicator
        let mut has_next_page = false;
        if let Some(current_last_edge) = edges.iter().last() {
            if let Ok(cursor) = current_last_edge.cursor.parse::<i32>() {
                let total_count = total_count_query
                    .filter(id.gt(cursor))
                    .count()
                    .get_result::<i64>(&conn)?;
                if total_count > 0 {
                    has_next_page = true;
                }
            }
        }
        Ok(NoticeConnection {
            edges,
            page_info: PageInfo { has_next_page },
        })
    }
}
