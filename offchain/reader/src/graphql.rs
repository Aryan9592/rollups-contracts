/* Copyright 2022 Cartesi Pte. Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

use diesel::pg::PgConnection;
use diesel::prelude::*;
use diesel::r2d2::{ConnectionManager, Pool};
use juniper_from_schema::graphql_schema_from_file;
use std::sync::Arc;
use tracing::debug;

// Generate Rust objects from current graphql schema
// To inspect generated code build with `JUNIPER_FROM_SCHEMA_DEBUG=1 cargo build`
graphql_schema_from_file!("../data/graphql/typeDefs.graphql");

use juniper::{Executor, FieldResult};

pub struct Context {
    // Connection is not thread safe to share between threads, we use connection pool
    pub db_pool: Arc<Pool<ConnectionManager<PgConnection>>>,
}
impl juniper::Context for Context {}

/// Graphql representation of the Notice
pub struct Notice {
    session_id: String,
    epoch_index: i32,
    input_index: i32,
    notice_index: i32,
    keccak: String,
    payload: String,
}

/// Necessary graphql boilerplate for Notice
impl NoticeFields for Notice {
    fn field_session_id(
        &self,
        _executor: &Executor<Context>,
    ) -> FieldResult<&String> {
        Ok(&self.session_id)
    }

    fn field_epoch_index(
        &self,
        _executor: &Executor<Context>,
    ) -> FieldResult<&i32> {
        Ok(&self.epoch_index as &i32)
    }

    fn field_input_index(
        &self,
        _executor: &Executor<Context>,
    ) -> FieldResult<&i32> {
        Ok(&self.input_index)
    }

    fn field_notice_index(
        &self,
        _executor: &Executor<Context>,
    ) -> FieldResult<&i32> {
        Ok(&self.notice_index)
    }

    fn field_keccak(
        &self,
        _executor: &Executor<Context>,
    ) -> FieldResult<&String> {
        Ok(&self.keccak)
    }

    fn field_payload(
        &self,
        _executor: &Executor<Context>,
    ) -> FieldResult<&String> {
        Ok(&self.payload)
    }
}

/// Reader must implement QueryFields trait for Query struct
pub struct Query;

/// This trait is generated by `graphql_schema_from_file!` based on the schema
impl QueryFields for Query {
    /// Handle getNotice query
    fn field_get_notice(
        &self,
        executor: &juniper::Executor<Context>,
        _trail: &QueryTrail<'_, Notice, Walked>,
        notice_keys: std::option::Option<NoticeKeys>,
    ) -> juniper::FieldResult<Vec<Notice>> {
        use rollups_data::database::{schema::notices::dsl::*, DbNotice};
        // note: graphql does not have native Int64, so it is only 32 bit integer
        debug!("Query: notice keys: {:?}", notice_keys);

        let conn = executor.context().db_pool.get()?;
        // Form database selection command based on graphql query parameters
        let mut query = notices.into_boxed();
        if let Some(notice_keys) = notice_keys {
            if let Some(id) = notice_keys.session_id {
                query = query.filter(session_id.eq(id));
            };

            if let Some(index) = notice_keys.epoch_index {
                query = query.filter(epoch_index.eq(index as i32));
            };

            if let Some(index) = notice_keys.input_index {
                query = query.filter(input_index.eq(index as i32));
            };

            if let Some(index) = notice_keys.notice_index {
                query = query.filter(notice_index.eq(index as i32));
            };
        }
        // Retrieve data from database
        let result = query.load::<DbNotice>(&conn)?;

        Ok(result
            .iter()
            .map(|db_notice| Notice {
                session_id: db_notice.session_id.clone(),
                epoch_index: db_notice.epoch_index as i32,
                input_index: db_notice.input_index as i32,
                notice_index: db_notice.notice_index as i32,
                keccak: db_notice.keccak.clone(),
                payload: "0x".to_string()
                    + hex::encode(
                        db_notice.payload.as_ref().unwrap_or(&Vec::new()),
                    )
                    .as_str(),
            })
            .collect())
    }
}
