{
  "contractName": "ValidatorManagerFacet1",
  "sourceName": "contracts/facets/alternatives/ValidatorManagerFacet1.sol",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "enum Result",
          "name": "result",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "bytes32[2]",
          "name": "claims",
          "type": "bytes32[2]"
        },
        {
          "indexed": false,
          "internalType": "address payable[2]",
          "name": "validators",
          "type": "address[2]"
        }
      ],
      "name": "ClaimReceived",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "enum Result",
          "name": "result",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "bytes32[2]",
          "name": "claims",
          "type": "bytes32[2]"
        },
        {
          "indexed": false,
          "internalType": "address payable[2]",
          "name": "validators",
          "type": "address[2]"
        }
      ],
      "name": "DisputeEnded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "claim",
          "type": "bytes32"
        }
      ],
      "name": "NewEpoch",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "getConsensusGoalMask",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCurrentAgreementMask",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCurrentClaim",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "bytecode": "0x608060405234801561001057600080fd5b5061011d806100206000396000f3fe6080604052348015600f57600080fd5b5060043610603c5760003560e01c8063012ad61c1460415780638219fda4146084578063f60238151460b3575b600080fd5b7f8ab37fef2b2e34c4b62ff9948ee661cdcf34e209d7c20f4d1f6e83085e93b1fe5463ffffffff165b60405163ffffffff90911681526020015b60405180910390f35b7f8ab37fef2b2e34c4b62ff9948ee661cdcf34e209d7c20f4d1f6e83085e93b1fc54604051908152602001607b565b7f8ab37fef2b2e34c4b62ff9948ee661cdcf34e209d7c20f4d1f6e83085e93b1fe54640100000000900463ffffffff16606a56fea2646970667358221220baf7efd21b96e2832103af9042838b6ea5cf8e2d5e26f14b4c5b041e9a0fd01364736f6c634300080d0033",
  "deployedBytecode": "0x6080604052348015600f57600080fd5b5060043610603c5760003560e01c8063012ad61c1460415780638219fda4146084578063f60238151460b3575b600080fd5b7f8ab37fef2b2e34c4b62ff9948ee661cdcf34e209d7c20f4d1f6e83085e93b1fe5463ffffffff165b60405163ffffffff90911681526020015b60405180910390f35b7f8ab37fef2b2e34c4b62ff9948ee661cdcf34e209d7c20f4d1f6e83085e93b1fc54604051908152602001607b565b7f8ab37fef2b2e34c4b62ff9948ee661cdcf34e209d7c20f4d1f6e83085e93b1fe54640100000000900463ffffffff16606a56fea2646970667358221220baf7efd21b96e2832103af9042838b6ea5cf8e2d5e26f14b4c5b041e9a0fd01364736f6c634300080d0033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getConsensusGoalMask()": {
        "returns": {
          "_0": "current consensus goal mask"
        }
      },
      "getCurrentAgreementMask()": {
        "returns": {
          "_0": "current state of agreement mask"
        }
      },
      "getCurrentClaim()": {
        "returns": {
          "_0": "current claim"
        }
      }
    },
    "version": 1
  },
  "evm": {
    "bytecode": {
      "functionDebugData": {},
      "generatedSources": [],
      "linkReferences": {},
      "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0x11D DUP1 PUSH2 0x20 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH1 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH1 0x3C JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x12AD61C EQ PUSH1 0x41 JUMPI DUP1 PUSH4 0x8219FDA4 EQ PUSH1 0x84 JUMPI DUP1 PUSH4 0xF6023815 EQ PUSH1 0xB3 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH32 0x8AB37FEF2B2E34C4B62FF9948EE661CDCF34E209D7C20F4D1F6E83085E93B1FE SLOAD PUSH4 0xFFFFFFFF AND JUMPDEST PUSH1 0x40 MLOAD PUSH4 0xFFFFFFFF SWAP1 SWAP2 AND DUP2 MSTORE PUSH1 0x20 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH32 0x8AB37FEF2B2E34C4B62FF9948EE661CDCF34E209D7C20F4D1F6E83085E93B1FC SLOAD PUSH1 0x40 MLOAD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x7B JUMP JUMPDEST PUSH32 0x8AB37FEF2B2E34C4B62FF9948EE661CDCF34E209D7C20F4D1F6E83085E93B1FE SLOAD PUSH5 0x100000000 SWAP1 DIV PUSH4 0xFFFFFFFF AND PUSH1 0x6A JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xBA 0xF7 0xEF 0xD2 SHL SWAP7 0xE2 DUP4 0x21 SUB 0xAF SWAP1 TIMESTAMP DUP4 DUP12 PUSH15 0xA5CF8E2D5E26F14B4C5B041E9A0FD0 SGT PUSH5 0x736F6C6343 STOP ADDMOD 0xD STOP CALLER ",
      "sourceMap": "867:1043:25:-:0;;;;;;;;;;;;;;;;;;;"
    },
    "deployedBytecode": {
      "functionDebugData": {
        "@diamondStorage_9142": {
          "entryPoint": null,
          "id": 9142,
          "parameterSlots": 0,
          "returnSlots": 1
        },
        "@getConsensusGoalMask_5245": {
          "entryPoint": null,
          "id": 5245,
          "parameterSlots": 0,
          "returnSlots": 1
        },
        "@getCurrentAgreementMask_5226": {
          "entryPoint": null,
          "id": 5226,
          "parameterSlots": 0,
          "returnSlots": 1
        },
        "@getCurrentClaim_5265": {
          "entryPoint": null,
          "id": 5265,
          "parameterSlots": 0,
          "returnSlots": 1
        },
        "abi_encode_tuple_t_bytes32__to_t_bytes32__fromStack_reversed": {
          "entryPoint": null,
          "id": null,
          "parameterSlots": 2,
          "returnSlots": 1
        },
        "abi_encode_tuple_t_uint32__to_t_uint32__fromStack_reversed": {
          "entryPoint": null,
          "id": null,
          "parameterSlots": 2,
          "returnSlots": 1
        }
      },
      "generatedSources": [
        {
          "ast": {
            "nodeType": "YulBlock",
            "src": "0:390:49",
            "statements": [
              {
                "nodeType": "YulBlock",
                "src": "6:3:49",
                "statements": []
              },
              {
                "body": {
                  "nodeType": "YulBlock",
                  "src": "113:93:49",
                  "statements": [
                    {
                      "nodeType": "YulAssignment",
                      "src": "123:26:49",
                      "value": {
                        "arguments": [
                          {
                            "name": "headStart",
                            "nodeType": "YulIdentifier",
                            "src": "135:9:49"
                          },
                          {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "146:2:49",
                            "type": "",
                            "value": "32"
                          }
                        ],
                        "functionName": {
                          "name": "add",
                          "nodeType": "YulIdentifier",
                          "src": "131:3:49"
                        },
                        "nodeType": "YulFunctionCall",
                        "src": "131:18:49"
                      },
                      "variableNames": [
                        {
                          "name": "tail",
                          "nodeType": "YulIdentifier",
                          "src": "123:4:49"
                        }
                      ]
                    },
                    {
                      "expression": {
                        "arguments": [
                          {
                            "name": "headStart",
                            "nodeType": "YulIdentifier",
                            "src": "165:9:49"
                          },
                          {
                            "arguments": [
                              {
                                "name": "value0",
                                "nodeType": "YulIdentifier",
                                "src": "180:6:49"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "188:10:49",
                                "type": "",
                                "value": "0xffffffff"
                              }
                            ],
                            "functionName": {
                              "name": "and",
                              "nodeType": "YulIdentifier",
                              "src": "176:3:49"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "176:23:49"
                          }
                        ],
                        "functionName": {
                          "name": "mstore",
                          "nodeType": "YulIdentifier",
                          "src": "158:6:49"
                        },
                        "nodeType": "YulFunctionCall",
                        "src": "158:42:49"
                      },
                      "nodeType": "YulExpressionStatement",
                      "src": "158:42:49"
                    }
                  ]
                },
                "name": "abi_encode_tuple_t_uint32__to_t_uint32__fromStack_reversed",
                "nodeType": "YulFunctionDefinition",
                "parameters": [
                  {
                    "name": "headStart",
                    "nodeType": "YulTypedName",
                    "src": "82:9:49",
                    "type": ""
                  },
                  {
                    "name": "value0",
                    "nodeType": "YulTypedName",
                    "src": "93:6:49",
                    "type": ""
                  }
                ],
                "returnVariables": [
                  {
                    "name": "tail",
                    "nodeType": "YulTypedName",
                    "src": "104:4:49",
                    "type": ""
                  }
                ],
                "src": "14:192:49"
              },
              {
                "body": {
                  "nodeType": "YulBlock",
                  "src": "312:76:49",
                  "statements": [
                    {
                      "nodeType": "YulAssignment",
                      "src": "322:26:49",
                      "value": {
                        "arguments": [
                          {
                            "name": "headStart",
                            "nodeType": "YulIdentifier",
                            "src": "334:9:49"
                          },
                          {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "345:2:49",
                            "type": "",
                            "value": "32"
                          }
                        ],
                        "functionName": {
                          "name": "add",
                          "nodeType": "YulIdentifier",
                          "src": "330:3:49"
                        },
                        "nodeType": "YulFunctionCall",
                        "src": "330:18:49"
                      },
                      "variableNames": [
                        {
                          "name": "tail",
                          "nodeType": "YulIdentifier",
                          "src": "322:4:49"
                        }
                      ]
                    },
                    {
                      "expression": {
                        "arguments": [
                          {
                            "name": "headStart",
                            "nodeType": "YulIdentifier",
                            "src": "364:9:49"
                          },
                          {
                            "name": "value0",
                            "nodeType": "YulIdentifier",
                            "src": "375:6:49"
                          }
                        ],
                        "functionName": {
                          "name": "mstore",
                          "nodeType": "YulIdentifier",
                          "src": "357:6:49"
                        },
                        "nodeType": "YulFunctionCall",
                        "src": "357:25:49"
                      },
                      "nodeType": "YulExpressionStatement",
                      "src": "357:25:49"
                    }
                  ]
                },
                "name": "abi_encode_tuple_t_bytes32__to_t_bytes32__fromStack_reversed",
                "nodeType": "YulFunctionDefinition",
                "parameters": [
                  {
                    "name": "headStart",
                    "nodeType": "YulTypedName",
                    "src": "281:9:49",
                    "type": ""
                  },
                  {
                    "name": "value0",
                    "nodeType": "YulTypedName",
                    "src": "292:6:49",
                    "type": ""
                  }
                ],
                "returnVariables": [
                  {
                    "name": "tail",
                    "nodeType": "YulTypedName",
                    "src": "303:4:49",
                    "type": ""
                  }
                ],
                "src": "211:177:49"
              }
            ]
          },
          "contents": "{\n    { }\n    function abi_encode_tuple_t_uint32__to_t_uint32__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, and(value0, 0xffffffff))\n    }\n    function abi_encode_tuple_t_bytes32__to_t_bytes32__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, value0)\n    }\n}",
          "id": 49,
          "language": "Yul",
          "name": "#utility.yul"
        }
      ],
      "immutableReferences": {},
      "linkReferences": {},
      "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH1 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH1 0x3C JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x12AD61C EQ PUSH1 0x41 JUMPI DUP1 PUSH4 0x8219FDA4 EQ PUSH1 0x84 JUMPI DUP1 PUSH4 0xF6023815 EQ PUSH1 0xB3 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH32 0x8AB37FEF2B2E34C4B62FF9948EE661CDCF34E209D7C20F4D1F6E83085E93B1FE SLOAD PUSH4 0xFFFFFFFF AND JUMPDEST PUSH1 0x40 MLOAD PUSH4 0xFFFFFFFF SWAP1 SWAP2 AND DUP2 MSTORE PUSH1 0x20 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH32 0x8AB37FEF2B2E34C4B62FF9948EE661CDCF34E209D7C20F4D1F6E83085E93B1FC SLOAD PUSH1 0x40 MLOAD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x7B JUMP JUMPDEST PUSH32 0x8AB37FEF2B2E34C4B62FF9948EE661CDCF34E209D7C20F4D1F6E83085E93B1FE SLOAD PUSH5 0x100000000 SWAP1 DIV PUSH4 0xFFFFFFFF AND PUSH1 0x6A JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xBA 0xF7 0xEF 0xD2 SHL SWAP7 0xE2 DUP4 0x21 SUB 0xAF SWAP1 TIMESTAMP DUP4 DUP12 PUSH15 0xA5CF8E2D5E26F14B4C5B041E9A0FD0 SGT PUSH5 0x736F6C6343 STOP ADDMOD 0xD STOP CALLER ",
      "sourceMap": "867:1043:25:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1009:249;1214:37;;;;1009:249;;;188:10:49;176:23;;;158:42;;146:2;131:18;1009:249:25;;;;;;;;1663:245;940:45:45;1870:31:25;1663:245;;357:25:49;;;345:2;330:18;1663:245:25;211:177:49;1348:245:25;1550:36;;;;;;;1348:245;"
    },
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "57000",
        "executionCost": "105",
        "totalCost": "57105"
      },
      "external": {
        "getConsensusGoalMask()": "2329",
        "getCurrentAgreementMask()": "2263",
        "getCurrentClaim()": "2280"
      }
    },
    "methodIdentifiers": {
      "getConsensusGoalMask()": "f6023815",
      "getCurrentAgreementMask()": "012ad61c",
      "getCurrentClaim()": "8219fda4"
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum Result\",\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32[2]\",\"name\":\"claims\",\"type\":\"bytes32[2]\"},{\"indexed\":false,\"internalType\":\"address payable[2]\",\"name\":\"validators\",\"type\":\"address[2]\"}],\"name\":\"ClaimReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum Result\",\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32[2]\",\"name\":\"claims\",\"type\":\"bytes32[2]\"},{\"indexed\":false,\"internalType\":\"address payable[2]\",\"name\":\"validators\",\"type\":\"address[2]\"}],\"name\":\"DisputeEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"claim\",\"type\":\"bytes32\"}],\"name\":\"NewEpoch\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getConsensusGoalMask\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentAgreementMask\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentClaim\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getConsensusGoalMask()\":{\"returns\":{\"_0\":\"current consensus goal mask\"}},\"getCurrentAgreementMask()\":{\"returns\":{\"_0\":\"current state of agreement mask\"}},\"getCurrentClaim()\":{\"returns\":{\"_0\":\"current claim\"}}},\"version\":1},\"userdoc\":{\"events\":{\"ClaimReceived(uint8,bytes32[2],address[2])\":{\"notice\":\"emitted on Claim received\"},\"DisputeEnded(uint8,bytes32[2],address[2])\":{\"notice\":\"emitted on Dispute end\"},\"NewEpoch(bytes32)\":{\"notice\":\"emitted on new Epoch\"}},\"kind\":\"user\",\"methods\":{\"getConsensusGoalMask()\":{\"notice\":\"get consensus goal mask\"},\"getCurrentAgreementMask()\":{\"notice\":\"get agreement mask\"},\"getCurrentClaim()\":{\"notice\":\"get current claim\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/alternatives/ValidatorManagerFacet1.sol\":\"ValidatorManagerFacet1\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/facets/alternatives/ValidatorManagerFacet1.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Validator Manager facet (alternative version)\\npragma solidity ^0.8.0;\\n\\nimport {IValidatorManager} from \\\"../../interfaces/IValidatorManager.sol\\\";\\n\\nimport {LibValidatorManager1} from \\\"../../libraries/alternatives/LibValidatorManager1.sol\\\";\\n\\ncontract ValidatorManagerFacet1 is IValidatorManager {\\n    /// @notice get agreement mask\\n    /// @return current state of agreement mask\\n    function getCurrentAgreementMask() public view returns (uint32) {\\n        LibValidatorManager1.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager1.diamondStorage();\\n        return validatorManagerDS.claimAgreementMask;\\n    }\\n\\n    /// @notice get consensus goal mask\\n    /// @return current consensus goal mask\\n    function getConsensusGoalMask() public view returns (uint32) {\\n        LibValidatorManager1.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager1.diamondStorage();\\n        return validatorManagerDS.consensusGoalMask;\\n    }\\n\\n    /// @notice get current claim\\n    /// @return current claim\\n    function getCurrentClaim() public view override returns (bytes32) {\\n        LibValidatorManager1.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager1.diamondStorage();\\n        return validatorManagerDS.currentClaim;\\n    }\\n}\\n\",\"keccak256\":\"0xf5d99b356cedfa2ae4d9c813c51b6af1551704af89f92f324430890915d8979f\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/IValidatorManager.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Validator Manager interface\\npragma solidity >=0.7.0;\\n\\n// NoConflict - No conflicting claims or consensus\\n// Consensus - All validators had equal claims\\n// Conflict - Claim is conflicting with previous one\\nenum Result {\\n    NoConflict,\\n    Consensus,\\n    Conflict\\n}\\n\\n// TODO: What is the incentive for validators to not just copy the first claim that arrived?\\ninterface IValidatorManager {\\n    /// @notice get current claim\\n    function getCurrentClaim() external view returns (bytes32);\\n\\n    /// @notice emitted on Claim received\\n    event ClaimReceived(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on Dispute end\\n    event DisputeEnded(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on new Epoch\\n    event NewEpoch(bytes32 claim);\\n}\\n\",\"keccak256\":\"0x7eccbaf15dc80cd402459e8c940b0012fd3d3b8d2882fa13798afe92a9ea3b86\",\"license\":\"Apache-2.0\"},\"contracts/libraries/alternatives/LibValidatorManager1.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Validator Manager library (alternative version)\\npragma solidity ^0.8.0;\\n\\nimport {Result} from \\\"../../interfaces/IValidatorManager.sol\\\";\\n\\n// TODO: this libray seems to be very unsafe, need to think about security implications\\nlibrary LibValidatorManager1 {\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"ValidatorManager.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        bytes32 currentClaim; // current claim - first claim of this epoch\\n        address payable[] validators; // current validators\\n        // A bit set for each validator that agrees with current claim,\\n        // on their respective positions\\n        uint32 claimAgreementMask;\\n        // Every validator who should approve (in order to reach consensus) will have a one set on this mask\\n        // This mask is updated if a validator is added or removed\\n        uint32 consensusGoalMask;\\n    }\\n\\n    /// @notice emitted on Claim received\\n    event ClaimReceived(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on Dispute end\\n    event DisputeEnded(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on new Epoch\\n    event NewEpoch(bytes32 claim);\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /// @notice called when a dispute ends in rollups\\n    /// @param ds diamond storage pointer\\n    /// @param winner address of dispute winner\\n    /// @param loser address of dispute loser\\n    /// @param winningClaim the winning claim\\n    /// @return result of dispute being finished\\n    function onDisputeEnd(\\n        DiamondStorage storage ds,\\n        address payable winner,\\n        address payable loser,\\n        bytes32 winningClaim\\n    )\\n        internal\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        // remove validator also removes validator from both bitmask\\n        removeFromValidatorSetAndBothBitmasks(ds, loser);\\n\\n        if (winningClaim == ds.currentClaim) {\\n            // first claim stood, dont need to update the bitmask\\n            return\\n                isConsensus(ds.claimAgreementMask, ds.consensusGoalMask)\\n                    ? emitDisputeEndedAndReturn(\\n                        Result.Consensus,\\n                        [winningClaim, bytes32(0)],\\n                        [winner, payable(0)]\\n                    )\\n                    : emitDisputeEndedAndReturn(\\n                        Result.NoConflict,\\n                        [winningClaim, bytes32(0)],\\n                        [winner, payable(0)]\\n                    );\\n        }\\n\\n        // if first claim lost, and other validators have agreed with it\\n        // there is a new dispute to be played\\n        if (ds.claimAgreementMask != 0) {\\n            return\\n                emitDisputeEndedAndReturn(\\n                    Result.Conflict,\\n                    [ds.currentClaim, winningClaim],\\n                    [getClaimerOfCurrentClaim(ds), winner]\\n                );\\n        }\\n        // else there are no valdiators that agree with losing claim\\n        // we can update current claim and check for consensus in case\\n        // the winner is the only validator left\\n        ds.currentClaim = winningClaim;\\n        ds.claimAgreementMask = updateClaimAgreementMask(ds, winner);\\n        return\\n            isConsensus(ds.claimAgreementMask, ds.consensusGoalMask)\\n                ? emitDisputeEndedAndReturn(\\n                    Result.Consensus,\\n                    [winningClaim, bytes32(0)],\\n                    [winner, payable(0)]\\n                )\\n                : emitDisputeEndedAndReturn(\\n                    Result.NoConflict,\\n                    [winningClaim, bytes32(0)],\\n                    [winner, payable(0)]\\n                );\\n    }\\n\\n    /// @notice called when a new epoch starts\\n    /// @param ds diamond storage pointer\\n    /// @return current claim\\n    function onNewEpoch(DiamondStorage storage ds) internal returns (bytes32) {\\n        bytes32 tmpClaim = ds.currentClaim;\\n\\n        // clear current claim\\n        ds.currentClaim = bytes32(0);\\n        // clear validator agreement bit mask\\n        ds.claimAgreementMask = 0;\\n\\n        emit NewEpoch(tmpClaim);\\n        return tmpClaim;\\n    }\\n\\n    /// @notice called when a claim is received by rollups\\n    /// @param ds diamond storage pointer\\n    /// @param sender address of sender of that claim\\n    /// @param claim claim received by rollups\\n    /// @return result of claim, Consensus | NoConflict | Conflict\\n    /// @return [currentClaim, conflicting claim] if there is Conflict\\n    ///         [currentClaim, bytes32(0)] if there is Consensus or NoConflcit\\n    /// @return [claimer1, claimer2] if there is  Conflcit\\n    ///         [claimer1, address(0)] if there is Consensus or NoConflcit\\n    function onClaim(\\n        DiamondStorage storage ds,\\n        address payable sender,\\n        bytes32 claim\\n    )\\n        internal\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        require(claim != bytes32(0), \\\"empty claim\\\");\\n        require(isValidator(ds, sender), \\\"sender not allowed\\\");\\n\\n        // cant return because a single claim might mean consensus\\n        if (ds.currentClaim == bytes32(0)) {\\n            ds.currentClaim = claim;\\n        }\\n\\n        if (claim != ds.currentClaim) {\\n            return\\n                emitClaimReceivedAndReturn(\\n                    Result.Conflict,\\n                    [ds.currentClaim, claim],\\n                    [getClaimerOfCurrentClaim(ds), sender]\\n                );\\n        }\\n        ds.claimAgreementMask = updateClaimAgreementMask(ds, sender);\\n\\n        return\\n            isConsensus(ds.claimAgreementMask, ds.consensusGoalMask)\\n                ? emitClaimReceivedAndReturn(\\n                    Result.Consensus,\\n                    [claim, bytes32(0)],\\n                    [sender, payable(0)]\\n                )\\n                : emitClaimReceivedAndReturn(\\n                    Result.NoConflict,\\n                    [claim, bytes32(0)],\\n                    [sender, payable(0)]\\n                );\\n    }\\n\\n    /// @notice emits dispute ended event and then return\\n    /// @param result to be emitted and returned\\n    /// @param claims to be emitted and returned\\n    /// @param validators to be emitted and returned\\n    /// @dev this function existis to make code more clear/concise\\n    function emitDisputeEndedAndReturn(\\n        Result result,\\n        bytes32[2] memory claims,\\n        address payable[2] memory validators\\n    )\\n        internal\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        emit DisputeEnded(result, claims, validators);\\n        return (result, claims, validators);\\n    }\\n\\n    /// @notice emits claim received event and then return\\n    /// @param result to be emitted and returned\\n    /// @param claims to be emitted and returned\\n    /// @param validators to be emitted and returned\\n    /// @dev this function existis to make code more clear/concise\\n    function emitClaimReceivedAndReturn(\\n        Result result,\\n        bytes32[2] memory claims,\\n        address payable[2] memory validators\\n    )\\n        internal\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        emit ClaimReceived(result, claims, validators);\\n        return (result, claims, validators);\\n    }\\n\\n    /// @notice get one of the validators that agreed with current claim\\n    /// @param ds diamond storage pointer\\n    /// @return validator that agreed with current claim\\n    function getClaimerOfCurrentClaim(DiamondStorage storage ds)\\n        internal\\n        view\\n        returns (address payable)\\n    {\\n        // TODO: we are always getting the first validator\\n        // on the array that agrees with the current claim to enter a dispute\\n        // should this be random?\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (ds.claimAgreementMask & (1 << i) != 0) {\\n                return ds.validators[i];\\n            }\\n        }\\n        revert(\\\"Agreeing validator not found\\\");\\n    }\\n\\n    /// @notice updates the consensus goal mask\\n    /// @param ds diamond storage pointer\\n    /// @return new consensus goal mask\\n    function updateConsensusGoalMask(DiamondStorage storage ds)\\n        internal\\n        view\\n        returns (uint32)\\n    {\\n        // consensus goal is a number where\\n        // all bits related to validators are turned on\\n        uint256 consensusMask = (1 << ds.validators.length) - 1;\\n        return uint32(consensusMask);\\n    }\\n\\n    /// @notice updates mask of validators that agreed with current claim\\n    /// @param ds diamond storage pointer\\n    /// @param sender address that of validator that will be included in mask\\n    /// @return new claim agreement mask\\n    function updateClaimAgreementMask(\\n        DiamondStorage storage ds,\\n        address payable sender\\n    ) internal view returns (uint32) {\\n        uint256 tmpClaimAgreement = ds.claimAgreementMask;\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (sender == ds.validators[i]) {\\n                tmpClaimAgreement = (tmpClaimAgreement | (1 << i));\\n                break;\\n            }\\n        }\\n\\n        return uint32(tmpClaimAgreement);\\n    }\\n\\n    /// @notice removes a validator\\n    /// @param ds diamond storage pointer\\n    /// @param validator address of validator to be removed\\n    function removeFromValidatorSetAndBothBitmasks(\\n        DiamondStorage storage ds,\\n        address validator\\n    ) internal {\\n        // put address(0) in validators position\\n        // removes validator from claim agreement bitmask\\n        // removes validator from consensus goal mask\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (validator == ds.validators[i]) {\\n                ds.validators[i] = payable(0);\\n                uint32 zeroMask = ~(uint32(1) << uint32(i));\\n                ds.claimAgreementMask = ds.claimAgreementMask & zeroMask;\\n                ds.consensusGoalMask = ds.consensusGoalMask & zeroMask;\\n                break;\\n            }\\n        }\\n    }\\n\\n    function isValidator(DiamondStorage storage ds, address sender)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (sender == ds.validators[i]) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function isConsensus(uint256 claimAgreementMask, uint256 consensusGoalMask)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return claimAgreementMask == consensusGoalMask;\\n    }\\n}\\n\",\"keccak256\":\"0xbdcef21255ed2750508e5b504fe3cf35fba99795f25cd3c1de1c65114cebde4a\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "storageLayout": {
    "storage": [],
    "types": null
  },
  "userdoc": {
    "events": {
      "ClaimReceived(uint8,bytes32[2],address[2])": {
        "notice": "emitted on Claim received"
      },
      "DisputeEnded(uint8,bytes32[2],address[2])": {
        "notice": "emitted on Dispute end"
      },
      "NewEpoch(bytes32)": {
        "notice": "emitted on new Epoch"
      }
    },
    "kind": "user",
    "methods": {
      "getConsensusGoalMask()": {
        "notice": "get consensus goal mask"
      },
      "getCurrentAgreementMask()": {
        "notice": "get agreement mask"
      },
      "getCurrentClaim()": {
        "notice": "get current claim"
      }
    },
    "version": 1
  }
}