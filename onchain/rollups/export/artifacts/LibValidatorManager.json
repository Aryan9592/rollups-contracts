{
  "contractName": "LibValidatorManager",
  "sourceName": "contracts/libraries/LibValidatorManager.sol",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "enum Result",
          "name": "result",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "bytes32[2]",
          "name": "claims",
          "type": "bytes32[2]"
        },
        {
          "indexed": false,
          "internalType": "address payable[2]",
          "name": "validators",
          "type": "address[2]"
        }
      ],
      "name": "ClaimReceived",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "enum Result",
          "name": "result",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "bytes32[2]",
          "name": "claims",
          "type": "bytes32[2]"
        },
        {
          "indexed": false,
          "internalType": "address payable[2]",
          "name": "validators",
          "type": "address[2]"
        }
      ],
      "name": "DisputeEnded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "claim",
          "type": "bytes32"
        }
      ],
      "name": "NewEpoch",
      "type": "event"
    }
  ],
  "bytecode": "0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220e9c722d071c3b444ba5298e71d7514a15a75e4ab75afc72e893b038ec00fbbd564736f6c634300080d0033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220e9c722d071c3b444ba5298e71d7514a15a75e4ab75afc72e893b038ec00fbbd564736f6c634300080d0033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "evm": {
    "bytecode": {
      "functionDebugData": {},
      "generatedSources": [],
      "linkReferences": {},
      "opcodes": "PUSH1 0x56 PUSH1 0x37 PUSH1 0xB DUP3 DUP3 DUP3 CODECOPY DUP1 MLOAD PUSH1 0x0 BYTE PUSH1 0x73 EQ PUSH1 0x2A JUMPI PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x0 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST ADDRESS PUSH1 0x0 MSTORE PUSH1 0x73 DUP2 MSTORE8 DUP3 DUP2 RETURN INVALID PUSH20 0x0 ADDRESS EQ PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xE9 0xC7 0x22 0xD0 PUSH18 0xC3B444BA5298E71D7514A15A75E4AB75AFC7 0x2E DUP10 EXTCODESIZE SUB DUP15 0xC0 0xF 0xBB 0xD5 PUSH5 0x736F6C6343 STOP ADDMOD 0xD STOP CALLER ",
      "sourceMap": "815:13224:44:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;815:13224:44;;;;;;;;;;;;;;;;;"
    },
    "deployedBytecode": {
      "functionDebugData": {},
      "generatedSources": [],
      "immutableReferences": {},
      "linkReferences": {},
      "opcodes": "PUSH20 0x0 ADDRESS EQ PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xE9 0xC7 0x22 0xD0 PUSH18 0xC3B444BA5298E71D7514A15A75E4AB75AFC7 0x2E DUP10 EXTCODESIZE SUB DUP15 0xC0 0xF 0xBB 0xD5 PUSH5 0x736F6C6343 STOP ADDMOD 0xD STOP CALLER ",
      "sourceMap": "815:13224:44:-:0;;;;;;;;"
    },
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "17200",
        "executionCost": "103",
        "totalCost": "17303"
      },
      "internal": {
        "claimFinalizedIncreaseCounts(struct LibValidatorManager.DiamondStorage storage pointer)": "infinite",
        "diamondStorage()": "infinite",
        "emitClaimReceivedAndReturn(enum Result,bytes32[2] memory,address payable[2] memory)": "infinite",
        "emitDisputeEndedAndReturn(enum Result,bytes32[2] memory,address payable[2] memory)": "infinite",
        "getClaimerOfCurrentClaim(struct LibValidatorManager.DiamondStorage storage pointer)": "infinite",
        "getMaxNumValidators(struct LibValidatorManager.DiamondStorage storage pointer)": "infinite",
        "getNumberOfClaimsByAddress(struct LibValidatorManager.DiamondStorage storage pointer,address payable)": "infinite",
        "getNumberOfClaimsByIndex(struct LibValidatorManager.DiamondStorage storage pointer,uint256)": "infinite",
        "getValidatorIndex(struct LibValidatorManager.DiamondStorage storage pointer,address)": "infinite",
        "isConsensus(struct LibValidatorManager.DiamondStorage storage pointer)": "infinite",
        "isValidator(struct LibValidatorManager.DiamondStorage storage pointer,address)": "infinite",
        "onClaim(struct LibValidatorManager.DiamondStorage storage pointer,address payable,bytes32)": "infinite",
        "onDisputeEnd(struct LibValidatorManager.DiamondStorage storage pointer,address payable,address payable,bytes32)": "infinite",
        "onNewEpoch(struct LibValidatorManager.DiamondStorage storage pointer)": "infinite",
        "removeValidator(struct LibValidatorManager.DiamondStorage storage pointer,address)": "infinite",
        "updateClaimAgreementMask(struct LibValidatorManager.DiamondStorage storage pointer,address payable)": "infinite"
      }
    },
    "methodIdentifiers": {}
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum Result\",\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32[2]\",\"name\":\"claims\",\"type\":\"bytes32[2]\"},{\"indexed\":false,\"internalType\":\"address payable[2]\",\"name\":\"validators\",\"type\":\"address[2]\"}],\"name\":\"ClaimReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum Result\",\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32[2]\",\"name\":\"claims\",\"type\":\"bytes32[2]\"},{\"indexed\":false,\"internalType\":\"address payable[2]\",\"name\":\"validators\",\"type\":\"address[2]\"}],\"name\":\"DisputeEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"claim\",\"type\":\"bytes32\"}],\"name\":\"NewEpoch\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"events\":{\"ClaimReceived(uint8,bytes32[2],address[2])\":{\"notice\":\"emitted on Claim received\"},\"DisputeEnded(uint8,bytes32[2],address[2])\":{\"notice\":\"emitted on Dispute end\"},\"NewEpoch(bytes32)\":{\"notice\":\"emitted on new Epoch\"}},\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/LibValidatorManager.sol\":\"LibValidatorManager\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/interfaces/IValidatorManager.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Validator Manager interface\\npragma solidity >=0.7.0;\\n\\n// NoConflict - No conflicting claims or consensus\\n// Consensus - All validators had equal claims\\n// Conflict - Claim is conflicting with previous one\\nenum Result {\\n    NoConflict,\\n    Consensus,\\n    Conflict\\n}\\n\\n// TODO: What is the incentive for validators to not just copy the first claim that arrived?\\ninterface IValidatorManager {\\n    /// @notice get current claim\\n    function getCurrentClaim() external view returns (bytes32);\\n\\n    /// @notice emitted on Claim received\\n    event ClaimReceived(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on Dispute end\\n    event DisputeEnded(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on new Epoch\\n    event NewEpoch(bytes32 claim);\\n}\\n\",\"keccak256\":\"0x7eccbaf15dc80cd402459e8c940b0012fd3d3b8d2882fa13798afe92a9ea3b86\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibClaimsMask.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title ClaimsMask library\\npragma solidity >=0.8.8;\\n\\n// ClaimsMask is used to keep track of the number of claims for up to 8 validators\\n// | agreement mask | consensus goal mask | #claims_validator7 | #claims_validator6 | ... | #claims_validator0 |\\n// |     8 bits     |        8 bits       |      30 bits       |      30 bits       | ... |      30 bits       |\\n// In Validator Manager, #claims_validator indicates the #claims the validator has made.\\n// In Fee Manager, #claims_validator indicates the #claims the validator has redeemed. In this case,\\n//      agreement mask and consensus goal mask are not used.\\n\\ntype ClaimsMask is uint256;\\n\\nlibrary LibClaimsMask {\\n    uint256 constant claimsBitLen = 30; // #bits used for each #claims\\n\\n    /// @notice this function creates a new ClaimsMask variable with value _value\\n    /// @param  _value the value following the format of ClaimsMask\\n    function newClaimsMask(uint256 _value) public pure returns (ClaimsMask) {\\n        return ClaimsMask.wrap(_value);\\n    }\\n\\n    /// @notice this function creates a new ClaimsMask variable with the consensus goal mask set,\\n    ///         according to the number of validators\\n    /// @param  _numValidators the number of validators\\n    function newClaimsMaskWithConsensusGoalSet(uint256 _numValidators)\\n        public\\n        pure\\n        returns (ClaimsMask)\\n    {\\n        require(_numValidators <= 8, \\\"up to 8 validators\\\");\\n        uint256 consensusMask = (1 << _numValidators) - 1;\\n        return ClaimsMask.wrap(consensusMask << 240); // 256 - 8 - 8 = 240\\n    }\\n\\n    /// @notice this function returns the #claims for the specified validator\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    ///     this index can be obtained though `getNumberOfClaimsByIndex` function in Validator Manager\\n    function getNumClaims(ClaimsMask _claimsMask, uint256 _validatorIndex)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        uint256 bitmask = (1 << claimsBitLen) - 1;\\n        return\\n            (ClaimsMask.unwrap(_claimsMask) >>\\n                (claimsBitLen * _validatorIndex)) & bitmask;\\n    }\\n\\n    /// @notice this function increases the #claims for the specified validator\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    /// @param  _value the increase amount\\n    function increaseNumClaims(\\n        ClaimsMask _claimsMask,\\n        uint256 _validatorIndex,\\n        uint256 _value\\n    ) public pure returns (ClaimsMask) {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        uint256 currentNum = getNumClaims(_claimsMask, _validatorIndex);\\n        uint256 newNum = currentNum + _value; // overflows checked by default with sol0.8\\n        return setNumClaims(_claimsMask, _validatorIndex, newNum);\\n    }\\n\\n    /// @notice this function sets the #claims for the specified validator\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    /// @param  _value the set value\\n    function setNumClaims(\\n        ClaimsMask _claimsMask,\\n        uint256 _validatorIndex,\\n        uint256 _value\\n    ) public pure returns (ClaimsMask) {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        require(_value <= ((1 << claimsBitLen) - 1), \\\"ClaimsMask Overflow\\\");\\n        uint256 bitmask = ~(((1 << claimsBitLen) - 1) <<\\n            (claimsBitLen * _validatorIndex));\\n        uint256 clearedClaimsMask = ClaimsMask.unwrap(_claimsMask) & bitmask;\\n        _claimsMask = ClaimsMask.wrap(\\n            clearedClaimsMask | (_value << (claimsBitLen * _validatorIndex))\\n        );\\n        return _claimsMask;\\n    }\\n\\n    /// @notice get consensus goal mask\\n    /// @param  _claimsMask the ClaimsMask value\\n    function clearAgreementMask(ClaimsMask _claimsMask)\\n        public\\n        pure\\n        returns (ClaimsMask)\\n    {\\n        uint256 clearedMask = ClaimsMask.unwrap(_claimsMask) & ((1 << 248) - 1); // 256 - 8 = 248\\n        return ClaimsMask.wrap(clearedMask);\\n    }\\n\\n    /// @notice get the entire agreement mask\\n    /// @param  _claimsMask the ClaimsMask value\\n    function getAgreementMask(ClaimsMask _claimsMask)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return (ClaimsMask.unwrap(_claimsMask) >> 248); // get the first 8 bits\\n    }\\n\\n    /// @notice check if a validator has already claimed\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    function alreadyClaimed(ClaimsMask _claimsMask, uint256 _validatorIndex)\\n        public\\n        pure\\n        returns (bool)\\n    {\\n        // get the first 8 bits. Then & operation on the validator's bit to see if it's set\\n        return\\n            (((ClaimsMask.unwrap(_claimsMask) >> 248) >> _validatorIndex) &\\n                1) != 0;\\n    }\\n\\n    /// @notice set agreement mask for the specified validator\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    function setAgreementMask(ClaimsMask _claimsMask, uint256 _validatorIndex)\\n        public\\n        pure\\n        returns (ClaimsMask)\\n    {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        uint256 setMask = (ClaimsMask.unwrap(_claimsMask) |\\n            (1 << (248 + _validatorIndex))); // 256 - 8 = 248\\n        return ClaimsMask.wrap(setMask);\\n    }\\n\\n    /// @notice get the entire consensus goal mask\\n    /// @param  _claimsMask the ClaimsMask value\\n    function getConsensusGoalMask(ClaimsMask _claimsMask)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return ((ClaimsMask.unwrap(_claimsMask) << 8) >> 248); // get the second 8 bits\\n    }\\n\\n    /// @notice remove validator from the ClaimsMask\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    function removeValidator(ClaimsMask _claimsMask, uint256 _validatorIndex)\\n        public\\n        pure\\n        returns (ClaimsMask)\\n    {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        uint256 claimsMaskValue = ClaimsMask.unwrap(_claimsMask);\\n        // remove validator from agreement bitmask\\n        uint256 zeroMask = ~(1 << (_validatorIndex + 248)); // 256 - 8 = 248\\n        claimsMaskValue = (claimsMaskValue & zeroMask);\\n        // remove validator from consensus goal mask\\n        zeroMask = ~(1 << (_validatorIndex + 240)); // 256 - 8 - 8 = 240\\n        claimsMaskValue = (claimsMaskValue & zeroMask);\\n        // remove validator from #claims\\n        return\\n            setNumClaims(ClaimsMask.wrap(claimsMaskValue), _validatorIndex, 0);\\n    }\\n}\\n\",\"keccak256\":\"0x581915d6dcd3aa9e447f89b8bf902bc4f4a72c40b9e8575e196741a8974ea74a\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibValidatorManager.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Validator Manager library\\npragma solidity ^0.8.0;\\n\\nimport {Result} from \\\"../interfaces/IValidatorManager.sol\\\";\\n\\nimport {LibClaimsMask, ClaimsMask} from \\\"../libraries/LibClaimsMask.sol\\\";\\n\\nlibrary LibValidatorManager {\\n    using LibClaimsMask for ClaimsMask;\\n\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"ValidatorManager.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        bytes32 currentClaim; // current claim - first claim of this epoch\\n        address payable[] validators; // up to 8 validators\\n        uint256 maxNumValidators; // the maximum number of validators, set in the constructor\\n        // A bit set used for up to 8 validators.\\n        // The first 8 bits are used to indicate whom supports the current claim\\n        // The second 8 bits are used to indicate those should have claimed in order to reach consensus\\n        // The following every 30 bits are used to indicate the number of total claims each validator has made\\n        // | agreement mask | consensus mask | #claims_validator7 | #claims_validator6 | ... | #claims_validator0 |\\n        // |     8 bits     |     8 bits     |      30 bits       |      30 bits       | ... |      30 bits       |\\n        ClaimsMask claimsMask;\\n    }\\n\\n    /// @notice emitted on Claim received\\n    event ClaimReceived(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on Dispute end\\n    event DisputeEnded(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on new Epoch\\n    event NewEpoch(bytes32 claim);\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /// @notice called when a dispute ends in rollups\\n    /// @param ds diamond storage pointer\\n    /// @param winner address of dispute winner\\n    /// @param loser address of dispute loser\\n    /// @param winningClaim the winnning claim\\n    /// @return result of dispute being finished\\n    function onDisputeEnd(\\n        DiamondStorage storage ds,\\n        address payable winner,\\n        address payable loser,\\n        bytes32 winningClaim\\n    )\\n        internal\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        removeValidator(ds, loser);\\n\\n        if (winningClaim == ds.currentClaim) {\\n            // first claim stood, dont need to update the bitmask\\n            return\\n                isConsensus(ds)\\n                    ? emitDisputeEndedAndReturn(\\n                        Result.Consensus,\\n                        [winningClaim, bytes32(0)],\\n                        [winner, payable(0)]\\n                    )\\n                    : emitDisputeEndedAndReturn(\\n                        Result.NoConflict,\\n                        [winningClaim, bytes32(0)],\\n                        [winner, payable(0)]\\n                    );\\n        }\\n\\n        // if first claim lost, and other validators have agreed with it\\n        // there is a new dispute to be played\\n        if (ds.claimsMask.getAgreementMask() != 0) {\\n            return\\n                emitDisputeEndedAndReturn(\\n                    Result.Conflict,\\n                    [ds.currentClaim, winningClaim],\\n                    [getClaimerOfCurrentClaim(ds), winner]\\n                );\\n        }\\n        // else there are no valdiators that agree with losing claim\\n        // we can update current claim and check for consensus in case\\n        // the winner is the only validator left\\n        ds.currentClaim = winningClaim;\\n        updateClaimAgreementMask(ds, winner);\\n        return\\n            isConsensus(ds)\\n                ? emitDisputeEndedAndReturn(\\n                    Result.Consensus,\\n                    [winningClaim, bytes32(0)],\\n                    [winner, payable(0)]\\n                )\\n                : emitDisputeEndedAndReturn(\\n                    Result.NoConflict,\\n                    [winningClaim, bytes32(0)],\\n                    [winner, payable(0)]\\n                );\\n    }\\n\\n    /// @notice called when a new epoch starts\\n    /// @param ds diamond storage pointer\\n    /// @return current claim\\n    function onNewEpoch(DiamondStorage storage ds) internal returns (bytes32) {\\n        // reward validators who has made the correct claim by increasing their #claims\\n        claimFinalizedIncreaseCounts(ds);\\n\\n        bytes32 tmpClaim = ds.currentClaim;\\n\\n        // clear current claim\\n        ds.currentClaim = bytes32(0);\\n        // clear validator agreement bit mask\\n        ds.claimsMask = ds.claimsMask.clearAgreementMask();\\n\\n        emit NewEpoch(tmpClaim);\\n        return tmpClaim;\\n    }\\n\\n    /// @notice called when a claim is received by rollups\\n    /// @param ds diamond storage pointer\\n    /// @param sender address of sender of that claim\\n    /// @param claim claim received by rollups\\n    /// @return result of claim, Consensus | NoConflict | Conflict\\n    /// @return [currentClaim, conflicting claim] if there is Conflict\\n    ///         [currentClaim, bytes32(0)] if there is Consensus or NoConflcit\\n    /// @return [claimer1, claimer2] if there is  Conflcit\\n    ///         [claimer1, address(0)] if there is Consensus or NoConflcit\\n    function onClaim(\\n        DiamondStorage storage ds,\\n        address payable sender,\\n        bytes32 claim\\n    )\\n        internal\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        require(claim != bytes32(0), \\\"empty claim\\\");\\n        require(isValidator(ds, sender), \\\"sender not allowed\\\");\\n\\n        // require the validator hasn't claimed in the same epoch before\\n        uint256 index = getValidatorIndex(ds, sender);\\n        require(\\n            !ds.claimsMask.alreadyClaimed(index),\\n            \\\"sender had claimed in this epoch before\\\"\\n        );\\n\\n        // cant return because a single claim might mean consensus\\n        if (ds.currentClaim == bytes32(0)) {\\n            ds.currentClaim = claim;\\n        }\\n\\n        if (claim != ds.currentClaim) {\\n            return\\n                emitClaimReceivedAndReturn(\\n                    Result.Conflict,\\n                    [ds.currentClaim, claim],\\n                    [getClaimerOfCurrentClaim(ds), sender]\\n                );\\n        }\\n        updateClaimAgreementMask(ds, sender);\\n\\n        return\\n            isConsensus(ds)\\n                ? emitClaimReceivedAndReturn(\\n                    Result.Consensus,\\n                    [claim, bytes32(0)],\\n                    [sender, payable(0)]\\n                )\\n                : emitClaimReceivedAndReturn(\\n                    Result.NoConflict,\\n                    [claim, bytes32(0)],\\n                    [sender, payable(0)]\\n                );\\n    }\\n\\n    /// @notice emits dispute ended event and then return\\n    /// @param result to be emitted and returned\\n    /// @param claims to be emitted and returned\\n    /// @param validators to be emitted and returned\\n    /// @dev this function existis to make code more clear/concise\\n    function emitDisputeEndedAndReturn(\\n        Result result,\\n        bytes32[2] memory claims,\\n        address payable[2] memory validators\\n    )\\n        internal\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        emit DisputeEnded(result, claims, validators);\\n        return (result, claims, validators);\\n    }\\n\\n    /// @notice emits claim received event and then return\\n    /// @param result to be emitted and returned\\n    /// @param claims to be emitted and returned\\n    /// @param validators to be emitted and returned\\n    /// @dev this function existis to make code more clear/concise\\n    function emitClaimReceivedAndReturn(\\n        Result result,\\n        bytes32[2] memory claims,\\n        address payable[2] memory validators\\n    )\\n        internal\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        emit ClaimReceived(result, claims, validators);\\n        return (result, claims, validators);\\n    }\\n\\n    /// @notice only call this function when a claim has been finalized\\n    ///         Either a consensus has been reached or challenge period has past\\n    /// @param ds pointer to diamond storage\\n    function claimFinalizedIncreaseCounts(DiamondStorage storage ds) internal {\\n        uint256 agreementMask = ds.claimsMask.getAgreementMask();\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            // if a validator agrees with the current claim\\n            if ((agreementMask & (1 << i)) != 0) {\\n                // increase #claims by 1\\n                ds.claimsMask = ds.claimsMask.increaseNumClaims(i, 1);\\n            }\\n        }\\n    }\\n\\n    /// @notice removes a validator\\n    /// @param ds diamond storage pointer\\n    /// @param validator address of validator to be removed\\n    function removeValidator(DiamondStorage storage ds, address validator)\\n        internal\\n    {\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (validator == ds.validators[i]) {\\n                // put address(0) in validators position\\n                ds.validators[i] = payable(0);\\n                // remove the validator from claimsMask\\n                ds.claimsMask = ds.claimsMask.removeValidator(i);\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @notice check if consensus has been reached\\n    /// @param ds pointer to diamond storage\\n    function isConsensus(DiamondStorage storage ds)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        ClaimsMask claimsMask = ds.claimsMask;\\n        return\\n            claimsMask.getAgreementMask() == claimsMask.getConsensusGoalMask();\\n    }\\n\\n    /// @notice get one of the validators that agreed with current claim\\n    /// @param ds diamond storage pointer\\n    /// @return validator that agreed with current claim\\n    function getClaimerOfCurrentClaim(DiamondStorage storage ds)\\n        internal\\n        view\\n        returns (address payable)\\n    {\\n        // TODO: we are always getting the first validator\\n        // on the array that agrees with the current claim to enter a dispute\\n        // should this be random?\\n        uint256 agreementMask = ds.claimsMask.getAgreementMask();\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (agreementMask & (1 << i) != 0) {\\n                return ds.validators[i];\\n            }\\n        }\\n        revert(\\\"Agreeing validator not found\\\");\\n    }\\n\\n    /// @notice updates mask of validators that agreed with current claim\\n    /// @param ds diamond storage pointer\\n    /// @param sender address of validator that will be included in mask\\n    function updateClaimAgreementMask(\\n        DiamondStorage storage ds,\\n        address payable sender\\n    ) internal {\\n        uint256 validatorIndex = getValidatorIndex(ds, sender);\\n        ds.claimsMask = ds.claimsMask.setAgreementMask(validatorIndex);\\n    }\\n\\n    /// @notice check if the sender is a validator\\n    /// @param ds pointer to diamond storage\\n    /// @param sender sender address\\n    function isValidator(DiamondStorage storage ds, address sender)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        require(sender != address(0), \\\"address 0\\\");\\n\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (sender == ds.validators[i]) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice find the validator and return the index or revert\\n    /// @param ds pointer to diamond storage\\n    /// @param sender validator address\\n    /// @return validator index or revert\\n    function getValidatorIndex(DiamondStorage storage ds, address sender)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        require(sender != address(0), \\\"address 0\\\");\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (sender == ds.validators[i]) return i;\\n        }\\n        revert(\\\"validator not found\\\");\\n    }\\n\\n    /// @notice get number of claims the sender has made\\n    /// @param ds pointer to diamond storage\\n    /// @param _sender validator address\\n    /// @return #claims\\n    function getNumberOfClaimsByAddress(\\n        DiamondStorage storage ds,\\n        address payable _sender\\n    ) internal view returns (uint256) {\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (_sender == ds.validators[i]) {\\n                return getNumberOfClaimsByIndex(ds, i);\\n            }\\n        }\\n        // if validator not found\\n        return 0;\\n    }\\n\\n    /// @notice get number of claims by the index in the validator set\\n    /// @param ds pointer to diamond storage\\n    /// @param index the index in validator set\\n    /// @return #claims\\n    function getNumberOfClaimsByIndex(DiamondStorage storage ds, uint256 index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return ds.claimsMask.getNumClaims(index);\\n    }\\n\\n    /// @notice get the maximum number of validators defined in validator manager\\n    /// @param ds pointer to diamond storage\\n    /// @return the maximum number of validators\\n    function getMaxNumValidators(DiamondStorage storage ds)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return ds.maxNumValidators;\\n    }\\n}\\n\",\"keccak256\":\"0xa25792dbbddcb4f5ec3ef71e463e2df9153a90fecfa4b2cd81e03a6a06a45e83\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "storageLayout": {
    "storage": [],
    "types": null
  },
  "userdoc": {
    "events": {
      "ClaimReceived(uint8,bytes32[2],address[2])": {
        "notice": "emitted on Claim received"
      },
      "DisputeEnded(uint8,bytes32[2],address[2])": {
        "notice": "emitted on Dispute end"
      },
      "NewEpoch(bytes32)": {
        "notice": "emitted on new Epoch"
      }
    },
    "kind": "user",
    "methods": {},
    "version": 1
  }
}