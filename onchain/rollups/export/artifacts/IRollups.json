{
  "contractName": "IRollups",
  "sourceName": "contracts/interfaces/IRollups.sol",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "epochNumber",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "claimer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "epochHash",
          "type": "bytes32"
        }
      ],
      "name": "Claim",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "epochNumber",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "epochHash",
          "type": "bytes32"
        }
      ],
      "name": "FinalizeEpoch",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "enum Phase",
          "name": "newPhase",
          "type": "uint8"
        }
      ],
      "name": "PhaseChange",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "winner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "loser",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "winningClaim",
          "type": "bytes32"
        }
      ],
      "name": "ResolveDispute",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_epochHash",
          "type": "bytes32"
        }
      ],
      "name": "claim",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "finalizeEpoch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCurrentEpoch",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "bytecode": "0x",
  "deployedBytecode": "0x",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "devdoc": {
    "events": {
      "Claim(uint256,address,bytes32)": {
        "params": {
          "claimer": "address of current claimer",
          "epochHash": "claim being submitted by this epoch",
          "epochNumber": "number of the epoch being submitted"
        }
      },
      "FinalizeEpoch(uint256,bytes32)": {
        "params": {
          "epochHash": "claim being submitted by this epoch",
          "epochNumber": "number of the epoch being finalized"
        }
      },
      "PhaseChange(uint8)": {
        "params": {
          "newPhase": "new phase"
        }
      },
      "ResolveDispute(address,address,bytes32)": {
        "params": {
          "loser": "loser of dispute",
          "winner": "winner of dispute",
          "winningClaim": "initial claim of winning validator"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "claim(bytes32)": {
        "details": "ValidatorManager makes sure that msg.sender is allowed      and that claim != bytes32(0) TODO: add signatures for aggregated claims",
        "params": {
          "_epochHash": "hash of epoch"
        }
      },
      "finalizeEpoch()": {
        "details": "can only be called if challenge period is over"
      },
      "getCurrentEpoch()": {
        "details": "if phase is input accumulation, then the epoch number is length      of finalized epochs array, else there are two epochs two non      finalized epochs, one awaiting consensus/dispute and another      accumulating input",
        "returns": {
          "_0": "index of current epoch"
        }
      }
    },
    "version": 1
  },
  "evm": {
    "bytecode": {
      "functionDebugData": {},
      "generatedSources": [],
      "linkReferences": {},
      "object": "",
      "opcodes": "",
      "sourceMap": ""
    },
    "deployedBytecode": {
      "functionDebugData": {},
      "generatedSources": [],
      "immutableReferences": {},
      "linkReferences": {},
      "object": "",
      "opcodes": "",
      "sourceMap": ""
    },
    "gasEstimates": null,
    "methodIdentifiers": {
      "claim(bytes32)": "bd66528a",
      "finalizeEpoch()": "82ae9ef7",
      "getCurrentEpoch()": "b97dd9e2"
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"epochHash\",\"type\":\"bytes32\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"epochHash\",\"type\":\"bytes32\"}],\"name\":\"FinalizeEpoch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum Phase\",\"name\":\"newPhase\",\"type\":\"uint8\"}],\"name\":\"PhaseChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"winningClaim\",\"type\":\"bytes32\"}],\"name\":\"ResolveDispute\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_epochHash\",\"type\":\"bytes32\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizeEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"Claim(uint256,address,bytes32)\":{\"params\":{\"claimer\":\"address of current claimer\",\"epochHash\":\"claim being submitted by this epoch\",\"epochNumber\":\"number of the epoch being submitted\"}},\"FinalizeEpoch(uint256,bytes32)\":{\"params\":{\"epochHash\":\"claim being submitted by this epoch\",\"epochNumber\":\"number of the epoch being finalized\"}},\"PhaseChange(uint8)\":{\"params\":{\"newPhase\":\"new phase\"}},\"ResolveDispute(address,address,bytes32)\":{\"params\":{\"loser\":\"loser of dispute\",\"winner\":\"winner of dispute\",\"winningClaim\":\"initial claim of winning validator\"}}},\"kind\":\"dev\",\"methods\":{\"claim(bytes32)\":{\"details\":\"ValidatorManager makes sure that msg.sender is allowed      and that claim != bytes32(0) TODO: add signatures for aggregated claims\",\"params\":{\"_epochHash\":\"hash of epoch\"}},\"finalizeEpoch()\":{\"details\":\"can only be called if challenge period is over\"},\"getCurrentEpoch()\":{\"details\":\"if phase is input accumulation, then the epoch number is length      of finalized epochs array, else there are two epochs two non      finalized epochs, one awaiting consensus/dispute and another      accumulating input\",\"returns\":{\"_0\":\"index of current epoch\"}}},\"version\":1},\"userdoc\":{\"events\":{\"Claim(uint256,address,bytes32)\":{\"notice\":\"claim submitted\"},\"FinalizeEpoch(uint256,bytes32)\":{\"notice\":\"epoch finalized\"},\"PhaseChange(uint8)\":{\"notice\":\"phase change\"},\"ResolveDispute(address,address,bytes32)\":{\"notice\":\"dispute resolved\"}},\"kind\":\"user\",\"methods\":{\"claim(bytes32)\":{\"notice\":\"claim the result of current epoch\"},\"finalizeEpoch()\":{\"notice\":\"finalize epoch after timeout\"},\"getCurrentEpoch()\":{\"notice\":\"returns index of current (accumulating) epoch\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/interfaces/IRollups.sol\":\"IRollups\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/interfaces/IRollups.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Rollups interface\\npragma solidity >=0.7.0;\\n\\n// InputAccumulation - Inputs being accumulated for currrent epoch\\n// AwaitingConsensus - No disagreeing claims (or no claims)\\n// AwaitingDispute - Waiting for dispute to be over\\n// inputs received during InputAccumulation will be included in the\\n// current epoch. Inputs received while WaitingClaims or ChallengesInProgress\\n// are accumulated for the next epoch\\nenum Phase {\\n    InputAccumulation,\\n    AwaitingConsensus,\\n    AwaitingDispute\\n}\\n\\ninterface IRollups {\\n    /// @notice claim the result of current epoch\\n    /// @param _epochHash hash of epoch\\n    /// @dev ValidatorManager makes sure that msg.sender is allowed\\n    ///      and that claim != bytes32(0)\\n    /// TODO: add signatures for aggregated claims\\n    function claim(bytes32 _epochHash) external;\\n\\n    /// @notice finalize epoch after timeout\\n    /// @dev can only be called if challenge period is over\\n    function finalizeEpoch() external;\\n\\n    /// @notice returns index of current (accumulating) epoch\\n    /// @return index of current epoch\\n    /// @dev if phase is input accumulation, then the epoch number is length\\n    ///      of finalized epochs array, else there are two epochs two non\\n    ///      finalized epochs, one awaiting consensus/dispute and another\\n    ///      accumulating input\\n    function getCurrentEpoch() external view returns (uint256);\\n\\n    /// @notice claim submitted\\n    /// @param epochHash claim being submitted by this epoch\\n    /// @param claimer address of current claimer\\n    /// @param epochNumber number of the epoch being submitted\\n    event Claim(\\n        uint256 indexed epochNumber,\\n        address claimer,\\n        bytes32 epochHash\\n    );\\n\\n    /// @notice epoch finalized\\n    /// @param epochNumber number of the epoch being finalized\\n    /// @param epochHash claim being submitted by this epoch\\n    event FinalizeEpoch(uint256 indexed epochNumber, bytes32 epochHash);\\n\\n    /// @notice dispute resolved\\n    /// @param winner winner of dispute\\n    /// @param loser loser of dispute\\n    /// @param winningClaim initial claim of winning validator\\n    event ResolveDispute(address winner, address loser, bytes32 winningClaim);\\n\\n    /// @notice phase change\\n    /// @param newPhase new phase\\n    event PhaseChange(Phase newPhase);\\n}\\n\",\"keccak256\":\"0x241c3ee8bb900067903ac836d5f3ee81eca587c7f225ad6df686478a6b27329b\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "storageLayout": {
    "storage": [],
    "types": null
  },
  "userdoc": {
    "events": {
      "Claim(uint256,address,bytes32)": {
        "notice": "claim submitted"
      },
      "FinalizeEpoch(uint256,bytes32)": {
        "notice": "epoch finalized"
      },
      "PhaseChange(uint8)": {
        "notice": "phase change"
      },
      "ResolveDispute(address,address,bytes32)": {
        "notice": "dispute resolved"
      }
    },
    "kind": "user",
    "methods": {
      "claim(bytes32)": {
        "notice": "claim the result of current epoch"
      },
      "finalizeEpoch()": {
        "notice": "finalize epoch after timeout"
      },
      "getCurrentEpoch()": {
        "notice": "returns index of current (accumulating) epoch"
      }
    },
    "version": 1
  }
}