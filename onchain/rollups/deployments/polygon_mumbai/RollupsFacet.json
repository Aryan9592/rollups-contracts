{
  "address": "0x0d581944a934F33F4797E5040c7Fb7173ec093A2",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "epochNumber",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "claimer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "epochHash",
          "type": "bytes32"
        }
      ],
      "name": "Claim",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "epochNumber",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "epochHash",
          "type": "bytes32"
        }
      ],
      "name": "FinalizeEpoch",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "enum Phase",
          "name": "newPhase",
          "type": "uint8"
        }
      ],
      "name": "PhaseChange",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "winner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "loser",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "winningClaim",
          "type": "bytes32"
        }
      ],
      "name": "ResolveDispute",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_epochHash",
          "type": "bytes32"
        }
      ],
      "name": "claim",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "finalizeEpoch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getChallengePeriod",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCurrentEpoch",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCurrentPhase",
      "outputs": [
        {
          "internalType": "enum Phase",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getInputAccumulationStart",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getInputDuration",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getSealingEpochTimestamp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTemplateHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xa334b8715dee4b6ff3dbfeacc251ec4b7e193f89e274bba69712c1ebfe8749a6",
  "receipt": {
    "to": null,
    "from": "0x18930e8a66a1DbE21D00581216789AAB7460Afd0",
    "contractAddress": "0x0d581944a934F33F4797E5040c7Fb7173ec093A2",
    "transactionIndex": 10,
    "gasUsed": "1442294",
    "logsBloom": "0x00000000000000020000000000000000000000000000000000000020000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000020000000000000000001000000000000000000000000004000000000000000000001000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000024000100000",
    "blockHash": "0x70a891bbde73f4583df00d7e445f75b30c5f99b07dc2aa63c21fb4e1b21f5f48",
    "transactionHash": "0xa334b8715dee4b6ff3dbfeacc251ec4b7e193f89e274bba69712c1ebfe8749a6",
    "logs": [
      {
        "transactionIndex": 10,
        "blockNumber": 26083258,
        "transactionHash": "0xa334b8715dee4b6ff3dbfeacc251ec4b7e193f89e274bba69712c1ebfe8749a6",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x00000000000000000000000018930e8a66a1dbe21d00581216789aab7460afd0",
          "0x000000000000000000000000c26880a0af2ea0c7e8130e6ec47af756465452e8"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000199ecb32b6766e0000000000000000000000000000000000000000000000000067119fc6af2b28000000000000000000000000000000000000000000000c0085a42b4080018b6a000000000000000000000000000000000000000000000000004d72d493f8b4ba000000000000000000000000000000000000000000000c0085bdca0bb2b801d8",
        "logIndex": 118,
        "blockHash": "0x70a891bbde73f4583df00d7e445f75b30c5f99b07dc2aa63c21fb4e1b21f5f48"
      }
    ],
    "blockNumber": 26083258,
    "cumulativeGasUsed": "3714681",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 4,
  "solcInputHash": "c0d3b4a0e9a8e1cfe79f1ef8cc16169f",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"epochHash\",\"type\":\"bytes32\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"epochHash\",\"type\":\"bytes32\"}],\"name\":\"FinalizeEpoch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum Phase\",\"name\":\"newPhase\",\"type\":\"uint8\"}],\"name\":\"PhaseChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"winningClaim\",\"type\":\"bytes32\"}],\"name\":\"ResolveDispute\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_epochHash\",\"type\":\"bytes32\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizeEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChallengePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPhase\",\"outputs\":[{\"internalType\":\"enum Phase\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInputAccumulationStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInputDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSealingEpochTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTemplateHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"claim(bytes32)\":{\"details\":\"ValidatorManager makes sure that msg.sender is allowed      and that claim != bytes32(0) TODO: add signatures for aggregated claims\",\"params\":{\"_epochHash\":\"hash of epoch\"}},\"finalizeEpoch()\":{\"details\":\"can only be called if challenge period is over\"},\"getCurrentEpoch()\":{\"details\":\"if phase is input accumulation, then the epoch number is length      of finalized epochs array, else there are two non finalized epochs,      one awaiting consensus/dispute and another accumulating input\",\"returns\":{\"_0\":\"index of current epoch\"}}},\"version\":1},\"userdoc\":{\"events\":{\"Claim(uint256,address,bytes32)\":{\"notice\":\"claim submitted\"},\"FinalizeEpoch(uint256,bytes32)\":{\"notice\":\"epoch finalized\"},\"PhaseChange(uint8)\":{\"notice\":\"phase change\"},\"ResolveDispute(address,address,bytes32)\":{\"notice\":\"dispute resolved\"}},\"kind\":\"user\",\"methods\":{\"claim(bytes32)\":{\"notice\":\"claim the result of current epoch\"},\"finalizeEpoch()\":{\"notice\":\"finalize epoch after timeout\"},\"getChallengePeriod()\":{\"notice\":\"returns the challenge period in seconds\"},\"getCurrentEpoch()\":{\"notice\":\"returns index of current (accumulating) epoch\"},\"getCurrentPhase()\":{\"notice\":\"returns the current phase\"},\"getInputAccumulationStart()\":{\"notice\":\"returns the input accumulation start timestamp\"},\"getInputDuration()\":{\"notice\":\"returns the input duration in seconds\"},\"getSealingEpochTimestamp()\":{\"notice\":\"returns the sealing epoch timestamp\"},\"getTemplateHash()\":{\"notice\":\"returns the machine's template hash\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/RollupsFacet.sol\":\"RollupsFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/facets/RollupsFacet.sol\":{\"content\":\"// Copyright 2022 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Rollups facet\\npragma solidity ^0.8.0;\\n\\nimport {IRollups, Phase} from \\\"../interfaces/IRollups.sol\\\";\\nimport {Result} from \\\"../interfaces/IValidatorManager.sol\\\";\\n\\nimport {LibRollups} from \\\"../libraries/LibRollups.sol\\\";\\nimport {LibInput} from \\\"../libraries/LibInput.sol\\\";\\nimport {LibOutput} from \\\"../libraries/LibOutput.sol\\\";\\nimport {LibValidatorManager} from \\\"../libraries/LibValidatorManager.sol\\\";\\n\\ncontract RollupsFacet is IRollups {\\n    ////\\n    //                             All claims agreed OR challenge period ended\\n    //                              functions: claim() or finalizeEpoch()\\n    //                        +--------------------------------------------------+\\n    //                        |                                                  |\\n    //               +--------v-----------+   new input after IPAD     +---------+----------+\\n    //               |                    +--------------------------->+                    |\\n    //   START  ---> | Input Accumulation |   firt claim after IPAD    | Awaiting Consensus |\\n    //               |                    +--------------------------->+                    |\\n    //               +-+------------------+                            +-----------------+--+\\n    //                 ^                                                                 ^  |\\n    //                 |                                              dispute resolved   |  |\\n    //                 |  dispute resolved                            before challenge   |  |\\n    //                 |  after challenge     +--------------------+  period ended       |  |\\n    //                 |  period ended        |                    +---------------------+  |\\n    //                 +----------------------+  Awaiting Dispute  |                        |\\n    //                                        |                    +<-----------------------+\\n    //                                        +--------------------+    conflicting claim\\n    ///\\n\\n    using LibRollups for LibRollups.DiamondStorage;\\n    using LibInput for LibInput.DiamondStorage;\\n    using LibOutput for LibOutput.DiamondStorage;\\n    using LibValidatorManager for LibValidatorManager.DiamondStorage;\\n\\n    /// @notice claim the result of current epoch\\n    /// @param _epochHash hash of epoch\\n    /// @dev ValidatorManager makes sure that msg.sender is allowed\\n    ///      and that claim != bytes32(0)\\n    /// TODO: add signatures for aggregated claims\\n    function claim(bytes32 _epochHash) public override {\\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\\n            .diamondStorage();\\n        LibInput.DiamondStorage storage inputDS = LibInput.diamondStorage();\\n        LibOutput.DiamondStorage storage outputDS = LibOutput.diamondStorage();\\n        LibValidatorManager.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\\n\\n        Result result;\\n        bytes32[2] memory claims;\\n        address payable[2] memory claimers;\\n\\n        Phase currentPhase = Phase(rollupsDS.currentPhase_int);\\n        uint256 inputAccumulationStart = rollupsDS.inputAccumulationStart;\\n        uint256 inputDuration = rollupsDS.inputDuration;\\n\\n        if (\\n            currentPhase == Phase.InputAccumulation &&\\n            block.timestamp > inputAccumulationStart + inputDuration\\n        ) {\\n            currentPhase = Phase.AwaitingConsensus;\\n            rollupsDS.currentPhase_int = uint32(Phase.AwaitingConsensus);\\n            emit PhaseChange(Phase.AwaitingConsensus);\\n\\n            // warns input of new epoch\\n            inputDS.onNewInputAccumulation();\\n            // update timestamp of sealing epoch proposal\\n            rollupsDS.sealingEpochTimestamp = uint32(block.timestamp);\\n        }\\n\\n        require(\\n            currentPhase == Phase.AwaitingConsensus,\\n            \\\"Phase != AwaitingConsensus\\\"\\n        );\\n        (result, claims, claimers) = validatorManagerDS.onClaim(\\n            payable(msg.sender),\\n            _epochHash\\n        );\\n\\n        // emit the claim event before processing it\\n        // so if the epoch is finalized in this claim (consensus)\\n        // the number of final epochs doesnt gets contaminated\\n        emit Claim(\\n            outputDS.getNumberOfFinalizedEpochs(),\\n            msg.sender,\\n            _epochHash\\n        );\\n\\n        rollupsDS.resolveValidatorResult(result, claims, claimers);\\n    }\\n\\n    /// @notice finalize epoch after timeout\\n    /// @dev can only be called if challenge period is over\\n    function finalizeEpoch() public override {\\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\\n            .diamondStorage();\\n        LibValidatorManager.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\\n\\n        Phase currentPhase = Phase(rollupsDS.currentPhase_int);\\n        require(\\n            currentPhase == Phase.AwaitingConsensus,\\n            \\\"Phase != Awaiting Consensus\\\"\\n        );\\n\\n        uint256 sealingEpochTimestamp = rollupsDS.sealingEpochTimestamp;\\n        uint256 challengePeriod = rollupsDS.challengePeriod;\\n        require(\\n            block.timestamp > sealingEpochTimestamp + challengePeriod,\\n            \\\"Challenge period not over\\\"\\n        );\\n\\n        require(\\n            validatorManagerDS.currentClaim != bytes32(0),\\n            \\\"No Claim to be finalized\\\"\\n        );\\n\\n        rollupsDS.startNewEpoch();\\n    }\\n\\n    /// @notice returns index of current (accumulating) epoch\\n    /// @return index of current epoch\\n    /// @dev if phase is input accumulation, then the epoch number is length\\n    ///      of finalized epochs array, else there are two non finalized epochs,\\n    ///      one awaiting consensus/dispute and another accumulating input\\n    function getCurrentEpoch() public view override returns (uint256) {\\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\\n            .diamondStorage();\\n        return rollupsDS.getCurrentEpoch();\\n    }\\n\\n    /// @notice returns the current phase\\n    function getCurrentPhase() public view returns (Phase) {\\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\\n            .diamondStorage();\\n        return Phase(rollupsDS.currentPhase_int);\\n    }\\n\\n    /// @notice returns the input accumulation start timestamp\\n    function getInputAccumulationStart() public view returns (uint256) {\\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\\n            .diamondStorage();\\n        return uint256(rollupsDS.inputAccumulationStart);\\n    }\\n\\n    /// @notice returns the sealing epoch timestamp\\n    function getSealingEpochTimestamp() public view returns (uint256) {\\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\\n            .diamondStorage();\\n        return uint256(rollupsDS.sealingEpochTimestamp);\\n    }\\n\\n    /// @notice returns the input duration in seconds\\n    function getInputDuration() public view returns (uint256) {\\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\\n            .diamondStorage();\\n        return uint256(rollupsDS.inputDuration);\\n    }\\n\\n    /// @notice returns the challenge period in seconds\\n    function getChallengePeriod() public view returns (uint256) {\\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\\n            .diamondStorage();\\n        return uint256(rollupsDS.challengePeriod);\\n    }\\n\\n    /// @notice returns the machine's template hash\\n    function getTemplateHash() public view returns (bytes32) {\\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\\n            .diamondStorage();\\n        return rollupsDS.templateHash;\\n    }\\n}\\n\",\"keccak256\":\"0xb4fa1894b1be726ec583569a1027ce9d509528fcb5e1e012228344b5a7343360\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/IRollups.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Rollups interface\\npragma solidity >=0.7.0;\\n\\n// InputAccumulation - Inputs being accumulated for currrent epoch\\n// AwaitingConsensus - No disagreeing claims (or no claims)\\n// AwaitingDispute - Waiting for dispute to be over\\n// inputs received during InputAccumulation will be included in the\\n// current epoch. Inputs received while WaitingClaims or ChallengesInProgress\\n// are accumulated for the next epoch\\nenum Phase {\\n    InputAccumulation,\\n    AwaitingConsensus,\\n    AwaitingDispute\\n}\\n\\ninterface IRollups {\\n    /// @notice claim the result of current epoch\\n    /// @param _epochHash hash of epoch\\n    /// @dev ValidatorManager makes sure that msg.sender is allowed\\n    ///      and that claim != bytes32(0)\\n    /// TODO: add signatures for aggregated claims\\n    function claim(bytes32 _epochHash) external;\\n\\n    /// @notice finalize epoch after timeout\\n    /// @dev can only be called if challenge period is over\\n    function finalizeEpoch() external;\\n\\n    /// @notice returns index of current (accumulating) epoch\\n    /// @return index of current epoch\\n    /// @dev if phase is input accumulation, then the epoch number is length\\n    ///      of finalized epochs array, else there are two epochs two non\\n    ///      finalized epochs, one awaiting consensus/dispute and another\\n    ///      accumulating input\\n    function getCurrentEpoch() external view returns (uint256);\\n\\n    /// @notice claim submitted\\n    /// @param epochHash claim being submitted by this epoch\\n    /// @param claimer address of current claimer\\n    /// @param epochNumber number of the epoch being submitted\\n    event Claim(\\n        uint256 indexed epochNumber,\\n        address claimer,\\n        bytes32 epochHash\\n    );\\n\\n    /// @notice epoch finalized\\n    /// @param epochNumber number of the epoch being finalized\\n    /// @param epochHash claim being submitted by this epoch\\n    event FinalizeEpoch(uint256 indexed epochNumber, bytes32 epochHash);\\n\\n    /// @notice dispute resolved\\n    /// @param winner winner of dispute\\n    /// @param loser loser of dispute\\n    /// @param winningClaim initial claim of winning validator\\n    event ResolveDispute(address winner, address loser, bytes32 winningClaim);\\n\\n    /// @notice phase change\\n    /// @param newPhase new phase\\n    event PhaseChange(Phase newPhase);\\n}\\n\",\"keccak256\":\"0x241c3ee8bb900067903ac836d5f3ee81eca587c7f225ad6df686478a6b27329b\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/IValidatorManager.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Validator Manager interface\\npragma solidity >=0.7.0;\\n\\n// NoConflict - No conflicting claims or consensus\\n// Consensus - All validators had equal claims\\n// Conflict - Claim is conflicting with previous one\\nenum Result {\\n    NoConflict,\\n    Consensus,\\n    Conflict\\n}\\n\\n// TODO: What is the incentive for validators to not just copy the first claim that arrived?\\ninterface IValidatorManager {\\n    /// @notice get current claim\\n    function getCurrentClaim() external view returns (bytes32);\\n\\n    /// @notice emitted on Claim received\\n    event ClaimReceived(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on Dispute end\\n    event DisputeEnded(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on new Epoch\\n    event NewEpoch(bytes32 claim);\\n}\\n\",\"keccak256\":\"0x7eccbaf15dc80cd402459e8c940b0012fd3d3b8d2882fa13798afe92a9ea3b86\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibClaimsMask.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title ClaimsMask library\\npragma solidity >=0.8.8;\\n\\n// ClaimsMask is used to keep track of the number of claims for up to 8 validators\\n// | agreement mask | consensus goal mask | #claims_validator7 | #claims_validator6 | ... | #claims_validator0 |\\n// |     8 bits     |        8 bits       |      30 bits       |      30 bits       | ... |      30 bits       |\\n// In Validator Manager, #claims_validator indicates the #claims the validator has made.\\n// In Fee Manager, #claims_validator indicates the #claims the validator has redeemed. In this case,\\n//      agreement mask and consensus goal mask are not used.\\n\\ntype ClaimsMask is uint256;\\n\\nlibrary LibClaimsMask {\\n    uint256 constant claimsBitLen = 30; // #bits used for each #claims\\n\\n    /// @notice this function creates a new ClaimsMask variable with value _value\\n    /// @param  _value the value following the format of ClaimsMask\\n    function newClaimsMask(uint256 _value) public pure returns (ClaimsMask) {\\n        return ClaimsMask.wrap(_value);\\n    }\\n\\n    /// @notice this function creates a new ClaimsMask variable with the consensus goal mask set,\\n    ///         according to the number of validators\\n    /// @param  _numValidators the number of validators\\n    function newClaimsMaskWithConsensusGoalSet(uint256 _numValidators)\\n        public\\n        pure\\n        returns (ClaimsMask)\\n    {\\n        require(_numValidators <= 8, \\\"up to 8 validators\\\");\\n        uint256 consensusMask = (1 << _numValidators) - 1;\\n        return ClaimsMask.wrap(consensusMask << 240); // 256 - 8 - 8 = 240\\n    }\\n\\n    /// @notice this function returns the #claims for the specified validator\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    ///     this index can be obtained though `getNumberOfClaimsByIndex` function in Validator Manager\\n    function getNumClaims(ClaimsMask _claimsMask, uint256 _validatorIndex)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        uint256 bitmask = (1 << claimsBitLen) - 1;\\n        return\\n            (ClaimsMask.unwrap(_claimsMask) >>\\n                (claimsBitLen * _validatorIndex)) & bitmask;\\n    }\\n\\n    /// @notice this function increases the #claims for the specified validator\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    /// @param  _value the increase amount\\n    function increaseNumClaims(\\n        ClaimsMask _claimsMask,\\n        uint256 _validatorIndex,\\n        uint256 _value\\n    ) public pure returns (ClaimsMask) {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        uint256 currentNum = getNumClaims(_claimsMask, _validatorIndex);\\n        uint256 newNum = currentNum + _value; // overflows checked by default with sol0.8\\n        return setNumClaims(_claimsMask, _validatorIndex, newNum);\\n    }\\n\\n    /// @notice this function sets the #claims for the specified validator\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    /// @param  _value the set value\\n    function setNumClaims(\\n        ClaimsMask _claimsMask,\\n        uint256 _validatorIndex,\\n        uint256 _value\\n    ) public pure returns (ClaimsMask) {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        require(_value <= ((1 << claimsBitLen) - 1), \\\"ClaimsMask Overflow\\\");\\n        uint256 bitmask = ~(((1 << claimsBitLen) - 1) <<\\n            (claimsBitLen * _validatorIndex));\\n        uint256 clearedClaimsMask = ClaimsMask.unwrap(_claimsMask) & bitmask;\\n        _claimsMask = ClaimsMask.wrap(\\n            clearedClaimsMask | (_value << (claimsBitLen * _validatorIndex))\\n        );\\n        return _claimsMask;\\n    }\\n\\n    /// @notice get consensus goal mask\\n    /// @param  _claimsMask the ClaimsMask value\\n    function clearAgreementMask(ClaimsMask _claimsMask)\\n        public\\n        pure\\n        returns (ClaimsMask)\\n    {\\n        uint256 clearedMask = ClaimsMask.unwrap(_claimsMask) & ((1 << 248) - 1); // 256 - 8 = 248\\n        return ClaimsMask.wrap(clearedMask);\\n    }\\n\\n    /// @notice get the entire agreement mask\\n    /// @param  _claimsMask the ClaimsMask value\\n    function getAgreementMask(ClaimsMask _claimsMask)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return (ClaimsMask.unwrap(_claimsMask) >> 248); // get the first 8 bits\\n    }\\n\\n    /// @notice check if a validator has already claimed\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    function alreadyClaimed(ClaimsMask _claimsMask, uint256 _validatorIndex)\\n        public\\n        pure\\n        returns (bool)\\n    {\\n        // get the first 8 bits. Then & operation on the validator's bit to see if it's set\\n        return\\n            (((ClaimsMask.unwrap(_claimsMask) >> 248) >> _validatorIndex) &\\n                1) != 0;\\n    }\\n\\n    /// @notice set agreement mask for the specified validator\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    function setAgreementMask(ClaimsMask _claimsMask, uint256 _validatorIndex)\\n        public\\n        pure\\n        returns (ClaimsMask)\\n    {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        uint256 setMask = (ClaimsMask.unwrap(_claimsMask) |\\n            (1 << (248 + _validatorIndex))); // 256 - 8 = 248\\n        return ClaimsMask.wrap(setMask);\\n    }\\n\\n    /// @notice get the entire consensus goal mask\\n    /// @param  _claimsMask the ClaimsMask value\\n    function getConsensusGoalMask(ClaimsMask _claimsMask)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return ((ClaimsMask.unwrap(_claimsMask) << 8) >> 248); // get the second 8 bits\\n    }\\n\\n    /// @notice remove validator from the ClaimsMask\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    function removeValidator(ClaimsMask _claimsMask, uint256 _validatorIndex)\\n        public\\n        pure\\n        returns (ClaimsMask)\\n    {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        uint256 claimsMaskValue = ClaimsMask.unwrap(_claimsMask);\\n        // remove validator from agreement bitmask\\n        uint256 zeroMask = ~(1 << (_validatorIndex + 248)); // 256 - 8 = 248\\n        claimsMaskValue = (claimsMaskValue & zeroMask);\\n        // remove validator from consensus goal mask\\n        zeroMask = ~(1 << (_validatorIndex + 240)); // 256 - 8 - 8 = 240\\n        claimsMaskValue = (claimsMaskValue & zeroMask);\\n        // remove validator from #claims\\n        return\\n            setNumClaims(ClaimsMask.wrap(claimsMaskValue), _validatorIndex, 0);\\n    }\\n}\\n\",\"keccak256\":\"0x581915d6dcd3aa9e447f89b8bf902bc4f4a72c40b9e8575e196741a8974ea74a\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibDisputeManager.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Dispute Manager library\\npragma solidity ^0.8.0;\\n\\nimport {LibRollups} from \\\"../libraries/LibRollups.sol\\\";\\n\\nlibrary LibDisputeManager {\\n    using LibRollups for LibRollups.DiamondStorage;\\n\\n    /// @notice initiates a dispute betweent two players\\n    /// @param claims conflicting claims\\n    /// @param claimers addresses of senders of conflicting claim\\n    /// @dev this is a mock implementation that just gives the win\\n    ///      to the address in the first posititon of claimers array\\n    function initiateDispute(\\n        bytes32[2] memory claims,\\n        address payable[2] memory claimers\\n    ) internal {\\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\\n            .diamondStorage();\\n        rollupsDS.resolveDispute(claimers[0], claimers[1], claims[0]);\\n    }\\n}\\n\",\"keccak256\":\"0x7d3fdb94a17c7f61ef8f6431f42eaa307b30398e3c24093c0526f449752563c9\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibInput.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Input library\\npragma solidity ^0.8.0;\\n\\nimport {LibRollups} from \\\"../libraries/LibRollups.sol\\\";\\n\\nlibrary LibInput {\\n    using LibRollups for LibRollups.DiamondStorage;\\n\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"Input.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        // always needs to keep track of two input boxes:\\n        // 1 for the input accumulation of next epoch\\n        // and 1 for the messages during current epoch. To save gas we alternate\\n        // between inputBox0 and inputBox1\\n        bytes32[] inputBox0;\\n        bytes32[] inputBox1;\\n        uint256 inputDriveSize; // size of input flashdrive\\n        uint256 currentInputBox;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /// @notice get input inside inbox of currently proposed claim\\n    /// @param ds diamond storage pointer\\n    /// @param index index of input inside that inbox\\n    /// @return hash of input at index index\\n    /// @dev currentInputBox being zero means that the inputs for\\n    ///      the claimed epoch are on input box one\\n    function getInput(DiamondStorage storage ds, uint256 index)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        return\\n            ds.currentInputBox == 0 ? ds.inputBox1[index] : ds.inputBox0[index];\\n    }\\n\\n    /// @notice get number of inputs inside inbox of currently proposed claim\\n    /// @param ds diamond storage pointer\\n    /// @return number of inputs on that input box\\n    /// @dev currentInputBox being zero means that the inputs for\\n    ///      the claimed epoch are on input box one\\n    function getNumberOfInputs(DiamondStorage storage ds)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            ds.currentInputBox == 0 ? ds.inputBox1.length : ds.inputBox0.length;\\n    }\\n\\n    /// @notice add input to processed by next epoch\\n    /// @param ds diamond storage pointer\\n    /// @param input input to be understood by offchain machine\\n    /// @dev offchain code is responsible for making sure\\n    ///      that input size is power of 2 and multiple of 8 since\\n    ///      the offchain machine has a 8 byte word\\n    function addInput(DiamondStorage storage ds, bytes memory input)\\n        internal\\n        returns (bytes32)\\n    {\\n        return addInputFromSender(ds, input, msg.sender);\\n    }\\n\\n    /// @notice add internal input to processed by next epoch\\n    /// @notice this function is to be reserved for internal usage only\\n    /// @notice for normal inputs, call `addInput` instead\\n    /// @param ds diamond storage pointer\\n    /// @param input input to be understood by offchain machine\\n    /// @dev offchain code is responsible for making sure\\n    ///      that input size is power of 2 and multiple of 8 since\\n    ///      the offchain machine has a 8 byte word\\n    function addInternalInput(DiamondStorage storage ds, bytes memory input)\\n        internal\\n        returns (bytes32)\\n    {\\n        return addInputFromSender(ds, input, address(this));\\n    }\\n\\n    /// @notice add input from a specific sender to processed by next epoch\\n    /// @notice this function is to be reserved for internal usage only\\n    /// @notice for normal inputs, call `addInput` instead\\n    /// @param ds diamond storage pointer\\n    /// @param input input to be understood by offchain machine\\n    /// @param sender input sender address\\n    /// @dev offchain code is responsible for making sure\\n    ///      that input size is power of 2 and multiple of 8 since\\n    ///      the offchain machine has a 8 byte word\\n    function addInputFromSender(\\n        DiamondStorage storage ds,\\n        bytes memory input,\\n        address sender\\n    ) internal returns (bytes32) {\\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\\n            .diamondStorage();\\n\\n        require(input.length <= ds.inputDriveSize, \\\"input len: [0,driveSize]\\\");\\n\\n        // notifyInput returns true if that input\\n        // belongs to a new epoch\\n        if (rollupsDS.notifyInput()) {\\n            swapInputBox(ds);\\n        }\\n\\n        // points to correct inputBox\\n        bytes32[] storage inputBox = ds.currentInputBox == 0\\n            ? ds.inputBox0\\n            : ds.inputBox1;\\n\\n        // get current epoch index\\n        uint256 currentEpoch = rollupsDS.getCurrentEpoch();\\n\\n        // keccak 64 bytes into 32 bytes\\n        bytes32 keccakMetadata = keccak256(\\n            abi.encode(\\n                sender,\\n                block.number,\\n                block.timestamp,\\n                currentEpoch, // epoch index\\n                inputBox.length // input index\\n            )\\n        );\\n\\n        bytes32 keccakInput = keccak256(input);\\n\\n        bytes32 inputHash = keccak256(abi.encode(keccakMetadata, keccakInput));\\n\\n        // add input to correct inbox\\n        inputBox.push(inputHash);\\n\\n        emit InputAdded(\\n            currentEpoch,\\n            inputBox.length - 1,\\n            sender,\\n            block.timestamp,\\n            input\\n        );\\n\\n        return inputHash;\\n    }\\n\\n    /// @notice called when a new input accumulation phase begins\\n    ///         swap inbox to receive inputs for upcoming epoch\\n    /// @param ds diamond storage pointer\\n    function onNewInputAccumulation(DiamondStorage storage ds) internal {\\n        swapInputBox(ds);\\n    }\\n\\n    /// @notice called when a new epoch begins, clears deprecated inputs\\n    /// @param ds diamond storage pointer\\n    function onNewEpoch(DiamondStorage storage ds) internal {\\n        // clear input box for new inputs\\n        // the current input box should be accumulating inputs\\n        // for the new epoch already. So we clear the other one.\\n        ds.currentInputBox == 0 ? delete ds.inputBox1 : delete ds.inputBox0;\\n    }\\n\\n    /// @notice changes current input box\\n    /// @param ds diamond storage pointer\\n    function swapInputBox(DiamondStorage storage ds) internal {\\n        ds.currentInputBox = (ds.currentInputBox == 0) ? 1 : 0;\\n    }\\n\\n    /// @notice input added\\n    /// @param epochNumber which epoch this input belongs to\\n    /// @param inputIndex index of the input just added\\n    /// @param sender msg.sender\\n    /// @param timestamp block.timestamp\\n    /// @param input input data\\n    event InputAdded(\\n        uint256 indexed epochNumber,\\n        uint256 indexed inputIndex,\\n        address sender,\\n        uint256 timestamp,\\n        bytes input\\n    );\\n}\\n\",\"keccak256\":\"0x9fec6d72c872e8f7f3adc79fa2bc5de8396d6ae97e2e23817e780e7d7a6cfaea\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibOutput.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Output library\\npragma solidity ^0.8.0;\\n\\nlibrary LibOutput {\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"Output.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        mapping(uint256 => uint256) voucherBitmask;\\n        bytes32[] epochHashes;\\n        bool lock; //reentrancy lock\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /// @notice to be called when an epoch is finalized\\n    /// @param ds diamond storage pointer\\n    /// @param epochHash hash of finalized epoch\\n    /// @dev an epoch being finalized means that its vouchers can be called\\n    function onNewEpoch(DiamondStorage storage ds, bytes32 epochHash) internal {\\n        ds.epochHashes.push(epochHash);\\n    }\\n\\n    /// @notice get number of finalized epochs\\n    /// @param ds diamond storage pointer\\n    function getNumberOfFinalizedEpochs(DiamondStorage storage ds)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return ds.epochHashes.length;\\n    }\\n}\\n\",\"keccak256\":\"0xd0f88e13210013e9d5bde03399bb76304d6ab4e1f06d01c7e3525adc87a2d65e\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibRollups.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Rollups library\\npragma solidity ^0.8.0;\\n\\nimport {Phase} from \\\"../interfaces/IRollups.sol\\\";\\nimport {Result} from \\\"../interfaces/IValidatorManager.sol\\\";\\n\\nimport {LibInput} from \\\"../libraries/LibInput.sol\\\";\\nimport {LibOutput} from \\\"../libraries/LibOutput.sol\\\";\\nimport {LibValidatorManager} from \\\"../libraries/LibValidatorManager.sol\\\";\\nimport {LibDisputeManager} from \\\"../libraries/LibDisputeManager.sol\\\";\\n\\nlibrary LibRollups {\\n    using LibInput for LibInput.DiamondStorage;\\n    using LibOutput for LibOutput.DiamondStorage;\\n    using LibValidatorManager for LibValidatorManager.DiamondStorage;\\n\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"Rollups.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        bytes32 templateHash; // state hash of the cartesi machine at t0\\n        uint32 inputDuration; // duration of input accumulation phase in seconds\\n        uint32 challengePeriod; // duration of challenge period in seconds\\n        uint32 inputAccumulationStart; // timestamp when current input accumulation phase started\\n        uint32 sealingEpochTimestamp; // timestamp on when a proposed epoch (claim) becomes challengeable\\n        uint32 currentPhase_int; // current phase in integer form\\n    }\\n\\n    /// @notice epoch finalized\\n    /// @param epochNumber number of the epoch being finalized\\n    /// @param epochHash claim being submitted by this epoch\\n    event FinalizeEpoch(uint256 indexed epochNumber, bytes32 epochHash);\\n\\n    /// @notice dispute resolved\\n    /// @param winner winner of dispute\\n    /// @param loser loser of dispute\\n    /// @param winningClaim initial claim of winning validator\\n    event ResolveDispute(address winner, address loser, bytes32 winningClaim);\\n\\n    /// @notice phase change\\n    /// @param newPhase new phase\\n    event PhaseChange(Phase newPhase);\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /// @notice called when new input arrives, manages the phase changes\\n    /// @param ds diamond storage pointer\\n    /// @dev can only be called by input contract\\n    function notifyInput(DiamondStorage storage ds) internal returns (bool) {\\n        Phase currentPhase = Phase(ds.currentPhase_int);\\n        uint256 inputAccumulationStart = ds.inputAccumulationStart;\\n        uint256 inputDuration = ds.inputDuration;\\n\\n        if (\\n            currentPhase == Phase.InputAccumulation &&\\n            block.timestamp > inputAccumulationStart + inputDuration\\n        ) {\\n            ds.currentPhase_int = uint32(Phase.AwaitingConsensus);\\n            emit PhaseChange(Phase.AwaitingConsensus);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /// @notice called when a dispute is resolved by the dispute manager\\n    /// @param ds diamond storage pointer\\n    /// @param winner winner of dispute\\n    /// @param loser loser of dispute\\n    /// @param winningClaim initial claim of winning validator\\n    function resolveDispute(\\n        DiamondStorage storage ds,\\n        address payable winner,\\n        address payable loser,\\n        bytes32 winningClaim\\n    ) internal {\\n        Result result;\\n        bytes32[2] memory claims;\\n        address payable[2] memory claimers;\\n        LibValidatorManager.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\\n\\n        (result, claims, claimers) = validatorManagerDS.onDisputeEnd(\\n            winner,\\n            loser,\\n            winningClaim\\n        );\\n\\n        // restart challenge period\\n        ds.sealingEpochTimestamp = uint32(block.timestamp);\\n\\n        emit ResolveDispute(winner, loser, winningClaim);\\n        resolveValidatorResult(ds, result, claims, claimers);\\n    }\\n\\n    /// @notice resolve results returned by validator manager\\n    /// @param ds diamond storage pointer\\n    /// @param result result from claim or dispute operation\\n    /// @param claims array of claims in case of new conflict\\n    /// @param claimers array of claimers in case of new conflict\\n    function resolveValidatorResult(\\n        DiamondStorage storage ds,\\n        Result result,\\n        bytes32[2] memory claims,\\n        address payable[2] memory claimers\\n    ) internal {\\n        if (result == Result.NoConflict) {\\n            Phase currentPhase = Phase(ds.currentPhase_int);\\n            if (currentPhase != Phase.AwaitingConsensus) {\\n                ds.currentPhase_int = uint32(Phase.AwaitingConsensus);\\n                emit PhaseChange(Phase.AwaitingConsensus);\\n            }\\n        } else if (result == Result.Consensus) {\\n            startNewEpoch(ds);\\n        } else {\\n            // for the case when result == Result.Conflict\\n            Phase currentPhase = Phase(ds.currentPhase_int);\\n            if (currentPhase != Phase.AwaitingDispute) {\\n                ds.currentPhase_int = uint32(Phase.AwaitingDispute);\\n                emit PhaseChange(Phase.AwaitingDispute);\\n            }\\n            LibDisputeManager.initiateDispute(claims, claimers);\\n        }\\n    }\\n\\n    /// @notice starts new epoch\\n    /// @param ds diamond storage pointer\\n    function startNewEpoch(DiamondStorage storage ds) internal {\\n        LibInput.DiamondStorage storage inputDS = LibInput.diamondStorage();\\n        LibOutput.DiamondStorage storage outputDS = LibOutput.diamondStorage();\\n        LibValidatorManager.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\\n\\n        // reset input accumulation start and deactivate challenge period start\\n        ds.currentPhase_int = uint32(Phase.InputAccumulation);\\n        emit PhaseChange(Phase.InputAccumulation);\\n        ds.inputAccumulationStart = uint32(block.timestamp);\\n        ds.sealingEpochTimestamp = type(uint32).max;\\n\\n        bytes32 finalClaim = validatorManagerDS.onNewEpoch();\\n\\n        // emit event before finalized epoch is added to the Output storage\\n        emit FinalizeEpoch(outputDS.getNumberOfFinalizedEpochs(), finalClaim);\\n\\n        outputDS.onNewEpoch(finalClaim);\\n        inputDS.onNewEpoch();\\n    }\\n\\n    /// @notice returns index of current (accumulating) epoch\\n    /// @param ds diamond storage pointer\\n    /// @return index of current epoch\\n    /// @dev if phase is input accumulation, then the epoch number is length\\n    ///      of finalized epochs array, else there are two non finalized epochs,\\n    ///      one awaiting consensus/dispute and another accumulating input\\n    function getCurrentEpoch(DiamondStorage storage ds)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        LibOutput.DiamondStorage storage outputDS = LibOutput.diamondStorage();\\n\\n        uint256 finalizedEpochs = outputDS.getNumberOfFinalizedEpochs();\\n\\n        Phase currentPhase = Phase(ds.currentPhase_int);\\n\\n        return\\n            currentPhase == Phase.InputAccumulation\\n                ? finalizedEpochs\\n                : finalizedEpochs + 1;\\n    }\\n}\\n\",\"keccak256\":\"0x04f72881c6032af40537ac14ff3720df2899a5746a42abd841b2292d66db11ca\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibValidatorManager.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Validator Manager library\\npragma solidity ^0.8.0;\\n\\nimport {Result} from \\\"../interfaces/IValidatorManager.sol\\\";\\n\\nimport {LibClaimsMask, ClaimsMask} from \\\"../libraries/LibClaimsMask.sol\\\";\\n\\nlibrary LibValidatorManager {\\n    using LibClaimsMask for ClaimsMask;\\n\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"ValidatorManager.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        bytes32 currentClaim; // current claim - first claim of this epoch\\n        address payable[] validators; // up to 8 validators\\n        uint256 maxNumValidators; // the maximum number of validators, set in the constructor\\n        // A bit set used for up to 8 validators.\\n        // The first 8 bits are used to indicate whom supports the current claim\\n        // The second 8 bits are used to indicate those should have claimed in order to reach consensus\\n        // The following every 30 bits are used to indicate the number of total claims each validator has made\\n        // | agreement mask | consensus mask | #claims_validator7 | #claims_validator6 | ... | #claims_validator0 |\\n        // |     8 bits     |     8 bits     |      30 bits       |      30 bits       | ... |      30 bits       |\\n        ClaimsMask claimsMask;\\n    }\\n\\n    /// @notice emitted on Claim received\\n    event ClaimReceived(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on Dispute end\\n    event DisputeEnded(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on new Epoch\\n    event NewEpoch(bytes32 claim);\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /// @notice called when a dispute ends in rollups\\n    /// @param ds diamond storage pointer\\n    /// @param winner address of dispute winner\\n    /// @param loser address of dispute loser\\n    /// @param winningClaim the winnning claim\\n    /// @return result of dispute being finished\\n    function onDisputeEnd(\\n        DiamondStorage storage ds,\\n        address payable winner,\\n        address payable loser,\\n        bytes32 winningClaim\\n    )\\n        internal\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        removeValidator(ds, loser);\\n\\n        if (winningClaim == ds.currentClaim) {\\n            // first claim stood, dont need to update the bitmask\\n            return\\n                isConsensus(ds)\\n                    ? emitDisputeEndedAndReturn(\\n                        Result.Consensus,\\n                        [winningClaim, bytes32(0)],\\n                        [winner, payable(0)]\\n                    )\\n                    : emitDisputeEndedAndReturn(\\n                        Result.NoConflict,\\n                        [winningClaim, bytes32(0)],\\n                        [winner, payable(0)]\\n                    );\\n        }\\n\\n        // if first claim lost, and other validators have agreed with it\\n        // there is a new dispute to be played\\n        if (ds.claimsMask.getAgreementMask() != 0) {\\n            return\\n                emitDisputeEndedAndReturn(\\n                    Result.Conflict,\\n                    [ds.currentClaim, winningClaim],\\n                    [getClaimerOfCurrentClaim(ds), winner]\\n                );\\n        }\\n        // else there are no valdiators that agree with losing claim\\n        // we can update current claim and check for consensus in case\\n        // the winner is the only validator left\\n        ds.currentClaim = winningClaim;\\n        updateClaimAgreementMask(ds, winner);\\n        return\\n            isConsensus(ds)\\n                ? emitDisputeEndedAndReturn(\\n                    Result.Consensus,\\n                    [winningClaim, bytes32(0)],\\n                    [winner, payable(0)]\\n                )\\n                : emitDisputeEndedAndReturn(\\n                    Result.NoConflict,\\n                    [winningClaim, bytes32(0)],\\n                    [winner, payable(0)]\\n                );\\n    }\\n\\n    /// @notice called when a new epoch starts\\n    /// @param ds diamond storage pointer\\n    /// @return current claim\\n    function onNewEpoch(DiamondStorage storage ds) internal returns (bytes32) {\\n        // reward validators who has made the correct claim by increasing their #claims\\n        claimFinalizedIncreaseCounts(ds);\\n\\n        bytes32 tmpClaim = ds.currentClaim;\\n\\n        // clear current claim\\n        ds.currentClaim = bytes32(0);\\n        // clear validator agreement bit mask\\n        ds.claimsMask = ds.claimsMask.clearAgreementMask();\\n\\n        emit NewEpoch(tmpClaim);\\n        return tmpClaim;\\n    }\\n\\n    /// @notice called when a claim is received by rollups\\n    /// @param ds diamond storage pointer\\n    /// @param sender address of sender of that claim\\n    /// @param claim claim received by rollups\\n    /// @return result of claim, Consensus | NoConflict | Conflict\\n    /// @return [currentClaim, conflicting claim] if there is Conflict\\n    ///         [currentClaim, bytes32(0)] if there is Consensus or NoConflcit\\n    /// @return [claimer1, claimer2] if there is  Conflcit\\n    ///         [claimer1, address(0)] if there is Consensus or NoConflcit\\n    function onClaim(\\n        DiamondStorage storage ds,\\n        address payable sender,\\n        bytes32 claim\\n    )\\n        internal\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        require(claim != bytes32(0), \\\"empty claim\\\");\\n        require(isValidator(ds, sender), \\\"sender not allowed\\\");\\n\\n        // require the validator hasn't claimed in the same epoch before\\n        uint256 index = getValidatorIndex(ds, sender);\\n        require(\\n            !ds.claimsMask.alreadyClaimed(index),\\n            \\\"sender had claimed in this epoch before\\\"\\n        );\\n\\n        // cant return because a single claim might mean consensus\\n        if (ds.currentClaim == bytes32(0)) {\\n            ds.currentClaim = claim;\\n        }\\n\\n        if (claim != ds.currentClaim) {\\n            return\\n                emitClaimReceivedAndReturn(\\n                    Result.Conflict,\\n                    [ds.currentClaim, claim],\\n                    [getClaimerOfCurrentClaim(ds), sender]\\n                );\\n        }\\n        updateClaimAgreementMask(ds, sender);\\n\\n        return\\n            isConsensus(ds)\\n                ? emitClaimReceivedAndReturn(\\n                    Result.Consensus,\\n                    [claim, bytes32(0)],\\n                    [sender, payable(0)]\\n                )\\n                : emitClaimReceivedAndReturn(\\n                    Result.NoConflict,\\n                    [claim, bytes32(0)],\\n                    [sender, payable(0)]\\n                );\\n    }\\n\\n    /// @notice emits dispute ended event and then return\\n    /// @param result to be emitted and returned\\n    /// @param claims to be emitted and returned\\n    /// @param validators to be emitted and returned\\n    /// @dev this function existis to make code more clear/concise\\n    function emitDisputeEndedAndReturn(\\n        Result result,\\n        bytes32[2] memory claims,\\n        address payable[2] memory validators\\n    )\\n        internal\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        emit DisputeEnded(result, claims, validators);\\n        return (result, claims, validators);\\n    }\\n\\n    /// @notice emits claim received event and then return\\n    /// @param result to be emitted and returned\\n    /// @param claims to be emitted and returned\\n    /// @param validators to be emitted and returned\\n    /// @dev this function existis to make code more clear/concise\\n    function emitClaimReceivedAndReturn(\\n        Result result,\\n        bytes32[2] memory claims,\\n        address payable[2] memory validators\\n    )\\n        internal\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        emit ClaimReceived(result, claims, validators);\\n        return (result, claims, validators);\\n    }\\n\\n    /// @notice only call this function when a claim has been finalized\\n    ///         Either a consensus has been reached or challenge period has past\\n    /// @param ds pointer to diamond storage\\n    function claimFinalizedIncreaseCounts(DiamondStorage storage ds) internal {\\n        uint256 agreementMask = ds.claimsMask.getAgreementMask();\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            // if a validator agrees with the current claim\\n            if ((agreementMask & (1 << i)) != 0) {\\n                // increase #claims by 1\\n                ds.claimsMask = ds.claimsMask.increaseNumClaims(i, 1);\\n            }\\n        }\\n    }\\n\\n    /// @notice removes a validator\\n    /// @param ds diamond storage pointer\\n    /// @param validator address of validator to be removed\\n    function removeValidator(DiamondStorage storage ds, address validator)\\n        internal\\n    {\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (validator == ds.validators[i]) {\\n                // put address(0) in validators position\\n                ds.validators[i] = payable(0);\\n                // remove the validator from claimsMask\\n                ds.claimsMask = ds.claimsMask.removeValidator(i);\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @notice check if consensus has been reached\\n    /// @param ds pointer to diamond storage\\n    function isConsensus(DiamondStorage storage ds)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        ClaimsMask claimsMask = ds.claimsMask;\\n        return\\n            claimsMask.getAgreementMask() == claimsMask.getConsensusGoalMask();\\n    }\\n\\n    /// @notice get one of the validators that agreed with current claim\\n    /// @param ds diamond storage pointer\\n    /// @return validator that agreed with current claim\\n    function getClaimerOfCurrentClaim(DiamondStorage storage ds)\\n        internal\\n        view\\n        returns (address payable)\\n    {\\n        // TODO: we are always getting the first validator\\n        // on the array that agrees with the current claim to enter a dispute\\n        // should this be random?\\n        uint256 agreementMask = ds.claimsMask.getAgreementMask();\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (agreementMask & (1 << i) != 0) {\\n                return ds.validators[i];\\n            }\\n        }\\n        revert(\\\"Agreeing validator not found\\\");\\n    }\\n\\n    /// @notice updates mask of validators that agreed with current claim\\n    /// @param ds diamond storage pointer\\n    /// @param sender address of validator that will be included in mask\\n    function updateClaimAgreementMask(\\n        DiamondStorage storage ds,\\n        address payable sender\\n    ) internal {\\n        uint256 validatorIndex = getValidatorIndex(ds, sender);\\n        ds.claimsMask = ds.claimsMask.setAgreementMask(validatorIndex);\\n    }\\n\\n    /// @notice check if the sender is a validator\\n    /// @param ds pointer to diamond storage\\n    /// @param sender sender address\\n    function isValidator(DiamondStorage storage ds, address sender)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        require(sender != address(0), \\\"address 0\\\");\\n\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (sender == ds.validators[i]) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice find the validator and return the index or revert\\n    /// @param ds pointer to diamond storage\\n    /// @param sender validator address\\n    /// @return validator index or revert\\n    function getValidatorIndex(DiamondStorage storage ds, address sender)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        require(sender != address(0), \\\"address 0\\\");\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (sender == ds.validators[i]) return i;\\n        }\\n        revert(\\\"validator not found\\\");\\n    }\\n\\n    /// @notice get number of claims the sender has made\\n    /// @param ds pointer to diamond storage\\n    /// @param _sender validator address\\n    /// @return #claims\\n    function getNumberOfClaimsByAddress(\\n        DiamondStorage storage ds,\\n        address payable _sender\\n    ) internal view returns (uint256) {\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (_sender == ds.validators[i]) {\\n                return getNumberOfClaimsByIndex(ds, i);\\n            }\\n        }\\n        // if validator not found\\n        return 0;\\n    }\\n\\n    /// @notice get number of claims by the index in the validator set\\n    /// @param ds pointer to diamond storage\\n    /// @param index the index in validator set\\n    /// @return #claims\\n    function getNumberOfClaimsByIndex(DiamondStorage storage ds, uint256 index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return ds.claimsMask.getNumClaims(index);\\n    }\\n\\n    /// @notice get the maximum number of validators defined in validator manager\\n    /// @param ds pointer to diamond storage\\n    /// @return the maximum number of validators\\n    function getMaxNumValidators(DiamondStorage storage ds)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return ds.maxNumValidators;\\n    }\\n}\\n\",\"keccak256\":\"0xa25792dbbddcb4f5ec3ef71e463e2df9153a90fecfa4b2cd81e03a6a06a45e83\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50611922806100206000396000f3fe608060405234801561001057600080fd5b50600436106100935760003560e01c8063a3a40ea511610066578063a3a40ea51461010b578063b97dd9e214610120578063bd66528a14610128578063ddf7bcf01461013b578063e17ba0121461015d57600080fd5b806354ee1da51461009857806361b12c66146100c95780637864b77d146100de57806382ae9ef714610101575b600080fd5b60008051602061186d83398151915254600160601b900463ffffffff165b6040519081526020015b60405180910390f35b6000805160206118cd833981519152546100b6565b60008051602061186d83398151915254640100000000900463ffffffff166100b6565b610109610178565b005b610113610304565b6040516100c0919061172e565b6100b661034b565b610109610136366004611741565b610365565b60008051602061186d83398151915254600160401b900463ffffffff166100b6565b60008051602061186d8339815191525463ffffffff166100b6565b60008051602061186d833981519152546000805160206118cd833981519152906000805160206118ad83398151915290600090600160801b900463ffffffff1660028111156101c9576101c96116fa565b905060018160028111156101df576101df6116fa565b146102315760405162461bcd60e51b815260206004820152601b60248201527f506861736520213d204177616974696e6720436f6e73656e737573000000000060448201526064015b60405180910390fd5b600183015463ffffffff600160601b82048116916401000000009004166102588183611770565b42116102a65760405162461bcd60e51b815260206004820152601960248201527f4368616c6c656e676520706572696f64206e6f74206f766572000000000000006044820152606401610228565b83546102f45760405162461bcd60e51b815260206004820152601860248201527f4e6f20436c61696d20746f2062652066696e616c697a656400000000000000006044820152606401610228565b6102fd8561057f565b5050505050565b60008051602061186d833981519152546000906000805160206118cd83398151915290600160801b900463ffffffff166002811115610345576103456116fa565b91505090565b60006000805160206118cd833981519152610345816106b7565b6000805160206118cd8339815191527f943d5d24442f02461445e15c5d7d4a4ef0acb0d32c5d6f6af37a6882249912ff7f0635ad75fae4d4e8d896461a635d23700076a1c3fd8da26276f18cb1c09ea5666000805160206118ad83398151915260006103cf6116aa565b6103d76116aa565b6001870154600090600160801b900463ffffffff1660028111156103fd576103fd6116fa565b600189015490915063ffffffff600160401b8204811691166000836002811115610429576104296116fa565b14801561043e575061043b8183611770565b42115b156104af5760018a8101805463ffffffff60801b1916600160801b17905560405190935060008051602061188d8339815191529061047d90859061172e565b60405180910390a161048e89610759565b60018a01805463ffffffff60601b1916600160601b4263ffffffff16021790555b60018360028111156104c3576104c36116fa565b146105105760405162461bcd60e51b815260206004820152601a60248201527f506861736520213d204177616974696e67436f6e73656e7375730000000000006044820152606401610228565b61051b87338d610765565b9197509550935061052d886001015490565b60408051338152602081018e90527fd31325e5dc55b03edf08c70299d3b1bc8d4c2ca8512c90138ddd03e3f54fce6c910160405180910390a26105728a8787876109fb565b5050505050505050505050565b60018101805463ffffffff60801b191690556040517f943d5d24442f02461445e15c5d7d4a4ef0acb0d32c5d6f6af37a6882249912ff907f0635ad75fae4d4e8d896461a635d23700076a1c3fd8da26276f18cb1c09ea566906000805160206118ad8339815191529060008051602061188d833981519152906106049060009061172e565b60405180910390a160018401805463ffffffff60601b1963ffffffff4216600160401b02166fffffffffffffffff0000000000000000199091161763ffffffff60601b179055600061065582610b51565b9050610662836001015490565b6040518281527f6e3d05bc77b9307d9ba574c7c3196a746edd51104ded1c823edc63be4b8a63c39060200160405180910390a2600180840180549182018155600090815260209020018190556102fd84610c1a565b7f0635ad75fae4d4e8d896461a635d23700076a1c3fd8da26276f18cb1c09ea5675460018201546000917f0635ad75fae4d4e8d896461a635d23700076a1c3fd8da26276f18cb1c09ea566918390600160801b900463ffffffff166002811115610723576107236116fa565b90506000816002811115610739576107396116fa565b1461074e57610749826001611770565b610750565b815b95945050505050565b61076281610c3d565b50565b600061076f6116aa565b6107776116aa565b836107b25760405162461bcd60e51b815260206004820152600b60248201526a656d70747920636c61696d60a81b6044820152606401610228565b6107bc8686610c5c565b6107fd5760405162461bcd60e51b81526020600482015260126024820152711cd95b99195c881b9bdd08185b1b1bddd95960721b6044820152606401610228565b60006108098787610d0b565b600388015460405163cb9f881360e01b815291925073dfE71bbad0ce232131dcc9e42e131ADD57ff39989163cb9f881391610851918590600401918252602082015260400190565b602060405180830381865af415801561086e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108929190611788565b156108ef5760405162461bcd60e51b815260206004820152602760248201527f73656e6465722068616420636c61696d656420696e20746869732065706f6368604482015266206265666f726560c81b6064820152608401610228565b86546108f9578487555b865485146109595761094d600260405180604001604052808a6000015481526020018881525060405180604001604052806109338c610dea565b6001600160a01b0390811682528b16602090910152610f11565b935093509350506109f2565b6109638787610f6a565b61096c8761100c565b6109b0576040805180820182528681526000602080830182905283518085019094526001600160a01b038a16845283018190526109ab92909190610f11565b6109ea565b6040805180820182528681526000602080830182905283518085019094526001600160a01b038a1684528301526109ea9160019190610f11565b935093509350505b93509350939050565b6000836002811115610a0f57610a0f6116fa565b03610a99576001840154600090600160801b900463ffffffff166002811115610a3a57610a3a6116fa565b90506001816002811115610a5057610a506116fa565b14610a93576001858101805463ffffffff60801b1916600160801b17905560405160008051602061188d83398151915291610a8a9161172e565b60405180910390a15b50610b4b565b6001836002811115610aad57610aad6116fa565b03610ac057610abb8461057f565b610b4b565b6001840154600090600160801b900463ffffffff166002811115610ae657610ae66116fa565b90506002816002811115610afc57610afc6116fa565b14610b415760018501805463ffffffff60801b1916600160811b17905560405160008051602061188d83398151915290610b389060029061172e565b60405180910390a15b6102fd8383611104565b50505050565b6000610b5c8261112d565b81546000835560038301546040516367bdc85360e11b8152600481019190915273dfE71bbad0ce232131dcc9e42e131ADD57ff39989063cf7b90a690602401602060405180830381865af4158015610bb8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bdc91906117b1565b60038401556040518181527fddc860800a99149017c480ec51523bf4143b7215e78956ae5c31e5c568f5383a9060200160405180910390a192915050565b600381015415610c2f576107628160006116c8565b6107626001820160006116c8565b600381015415610c4e576000610c51565b60015b60ff16600390910155565b60006001600160a01b038216610ca05760405162461bcd60e51b815260206004820152600960248201526806164647265737320360bc1b6044820152606401610228565b60005b6001840154811015610cff57836001018181548110610cc457610cc46117ca565b6000918252602090912001546001600160a01b0390811690841603610ced576001915050610d05565b80610cf7816117e0565b915050610ca3565b50600090505b92915050565b60006001600160a01b038216610d4f5760405162461bcd60e51b815260206004820152600960248201526806164647265737320360bc1b6044820152606401610228565b60005b6001840154811015610dab57836001018181548110610d7357610d736117ca565b6000918252602090912001546001600160a01b0390811690841603610d99579050610d05565b80610da3816117e0565b915050610d52565b5060405162461bcd60e51b81526020600482015260136024820152721d985b1a59185d1bdc881b9bdd08199bdd5b99606a1b6044820152606401610228565b6003810154604051623ea57d60ea1b81526004810191909152600090819073dfE71bbad0ce232131dcc9e42e131ADD57ff39989063fa95f40090602401602060405180830381865af4158015610e44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e6891906117b1565b905060005b6001840154811015610ec8576001811b821615610eb657836001018181548110610e9957610e996117ca565b6000918252602090912001546001600160a01b0316949350505050565b80610ec0816117e0565b915050610e6d565b5060405162461bcd60e51b815260206004820152601c60248201527f4167726565696e672076616c696461746f72206e6f7420666f756e64000000006044820152606401610228565b6000610f1b6116aa565b610f236116aa565b7f495383aed97965c56495cdbadedfe9667a1b028c54d3fc4b5335895146e02b70868686604051610f56939291906117f9565b60405180910390a150939492935090919050565b6000610f768383610d0b565b600384015460405163335c20d760e21b815291925073dfE71bbad0ce232131dcc9e42e131ADD57ff39989163cd70835c91610fbe918590600401918252602082015260400190565b602060405180830381865af4158015610fdb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fff91906117b1565b8360030181905550505050565b6003810154604051636a02b7ff60e11b8152600481018290526000919073dfE71bbad0ce232131dcc9e42e131ADD57ff39989063d4056ffe90602401602060405180830381865af4158015611065573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061108991906117b1565b604051623ea57d60ea1b81526004810183905273dfE71bbad0ce232131dcc9e42e131ADD57ff39989063fa95f40090602401602060405180830381865af41580156110d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110fc91906117b1565b149392505050565b8051602082015183516000805160206118cd8339815191529261112892849261126a565b505050565b6003810154604051623ea57d60ea1b815260009173dfE71bbad0ce232131dcc9e42e131ADD57ff39989163fa95f4009161116d9160040190815260200190565b602060405180830381865af415801561118a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111ae91906117b1565b905060005b6001830154811015611128576001811b8216156112585760038301546040516314bc74ad60e21b81526004810191909152602481018290526001604482015273dfE71bbad0ce232131dcc9e42e131ADD57ff3998906352f1d2b490606401602060405180830381865af415801561122e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061125291906117b1565b60038401555b80611262816117e0565b9150506111b3565b60006112746116aa565b61127c6116aa565b6000805160206118ad83398151915261129781888888611320565b60018b01805463ffffffff60601b1916600160601b4263ffffffff1602179055604080516001600160a01b03808d1682528b16602082015290810189905292965090945092507f2afbde4d47160a9c5de25b0df88d5b83e705286f2a447cac162db5e99ad6f5d29060600160405180910390a1611316888585856109fb565b5050505050505050565b600061132a6116aa565b6113326116aa565b61133c8786611545565b865484036113d65761134d8761100c565b611391576040805180820182528581526000602080830182905283518085019094526001600160a01b038a168452830181905261138c92909190611665565b6113cb565b6040805180820182528581526000602080830182905283518085019094526001600160a01b038a1684528301526113cb9160019190611665565b92509250925061153b565b6003870154604051623ea57d60ea1b8152600481019190915273dfE71bbad0ce232131dcc9e42e131ADD57ff39989063fa95f40090602401602060405180830381865af415801561142b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061144f91906117b1565b156114a0576113cb600260405180604001604052808a6000015481526020018781525060405180604001604052806114868c610dea565b6001600160a01b0390811682528b16602090910152611665565b8387556114ad8787610f6a565b6114b68761100c565b6114fa576040805180820182528581526000602080830182905283518085019094526001600160a01b038a16845283018190526114f592909190611665565b611534565b6040805180820182528581526000602080830182905283518085019094526001600160a01b038a1684528301526115349160019190611665565b9250925092505b9450945094915050565b60005b600183015481101561112857826001018181548110611569576115696117ca565b6000918252602090912001546001600160a01b039081169083160361165357600083600101828154811061159f5761159f6117ca565b600091825260209091200180546001600160a01b0319166001600160a01b03929092169190911790556003830154604051632b099ae360e21b815260048101919091526024810182905273dfE71bbad0ce232131dcc9e42e131ADD57ff39989063ac266b8c90604401602060405180830381865af4158015611625573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061164991906117b1565b6003840155505050565b8061165d816117e0565b915050611548565b600061166f6116aa565b6116776116aa565b7f09201c193a07cae1df95ae692cc698685574c942a04514c48a4c3249f38594ff868686604051610f56939291906117f9565b60405180604001604052806002906020820280368337509192915050565b508054600082559060005260206000209081019061076291905b808211156116f657600081556001016116e2565b5090565b634e487b7160e01b600052602160045260246000fd5b6003811061076257634e487b7160e01b600052602160045260246000fd5b6020810161173b83611710565b91905290565b60006020828403121561175357600080fd5b5035919050565b634e487b7160e01b600052601160045260246000fd5b600082198211156117835761178361175a565b500190565b60006020828403121561179a57600080fd5b815180151581146117aa57600080fd5b9392505050565b6000602082840312156117c357600080fd5b5051919050565b634e487b7160e01b600052603260045260246000fd5b6000600182016117f2576117f261175a565b5060010190565b60a0810161180685611710565b84825260208083018560005b600281101561182f57815183529183019190830190600101611812565b505050606083018460005b60028110156118605781516001600160a01b03168352918301919083019060010161183a565b5050505094935050505056fed32d7f90491bee81172a406b65f3270d810392fe53bb0379dde8bdd4e624189ded606d544c2202d032d2626c390923e6f260ca5d89625bba0cfe70d2bdda4e8f8ab37fef2b2e34c4b62ff9948ee661cdcf34e209d7c20f4d1f6e83085e93b1fcd32d7f90491bee81172a406b65f3270d810392fe53bb0379dde8bdd4e624189ca26469706673582212206ad80b2d7d7db0dbe765df1ce64bbb0b18ab0328debb5a025393620e1d30933564736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100935760003560e01c8063a3a40ea511610066578063a3a40ea51461010b578063b97dd9e214610120578063bd66528a14610128578063ddf7bcf01461013b578063e17ba0121461015d57600080fd5b806354ee1da51461009857806361b12c66146100c95780637864b77d146100de57806382ae9ef714610101575b600080fd5b60008051602061186d83398151915254600160601b900463ffffffff165b6040519081526020015b60405180910390f35b6000805160206118cd833981519152546100b6565b60008051602061186d83398151915254640100000000900463ffffffff166100b6565b610109610178565b005b610113610304565b6040516100c0919061172e565b6100b661034b565b610109610136366004611741565b610365565b60008051602061186d83398151915254600160401b900463ffffffff166100b6565b60008051602061186d8339815191525463ffffffff166100b6565b60008051602061186d833981519152546000805160206118cd833981519152906000805160206118ad83398151915290600090600160801b900463ffffffff1660028111156101c9576101c96116fa565b905060018160028111156101df576101df6116fa565b146102315760405162461bcd60e51b815260206004820152601b60248201527f506861736520213d204177616974696e6720436f6e73656e737573000000000060448201526064015b60405180910390fd5b600183015463ffffffff600160601b82048116916401000000009004166102588183611770565b42116102a65760405162461bcd60e51b815260206004820152601960248201527f4368616c6c656e676520706572696f64206e6f74206f766572000000000000006044820152606401610228565b83546102f45760405162461bcd60e51b815260206004820152601860248201527f4e6f20436c61696d20746f2062652066696e616c697a656400000000000000006044820152606401610228565b6102fd8561057f565b5050505050565b60008051602061186d833981519152546000906000805160206118cd83398151915290600160801b900463ffffffff166002811115610345576103456116fa565b91505090565b60006000805160206118cd833981519152610345816106b7565b6000805160206118cd8339815191527f943d5d24442f02461445e15c5d7d4a4ef0acb0d32c5d6f6af37a6882249912ff7f0635ad75fae4d4e8d896461a635d23700076a1c3fd8da26276f18cb1c09ea5666000805160206118ad83398151915260006103cf6116aa565b6103d76116aa565b6001870154600090600160801b900463ffffffff1660028111156103fd576103fd6116fa565b600189015490915063ffffffff600160401b8204811691166000836002811115610429576104296116fa565b14801561043e575061043b8183611770565b42115b156104af5760018a8101805463ffffffff60801b1916600160801b17905560405190935060008051602061188d8339815191529061047d90859061172e565b60405180910390a161048e89610759565b60018a01805463ffffffff60601b1916600160601b4263ffffffff16021790555b60018360028111156104c3576104c36116fa565b146105105760405162461bcd60e51b815260206004820152601a60248201527f506861736520213d204177616974696e67436f6e73656e7375730000000000006044820152606401610228565b61051b87338d610765565b9197509550935061052d886001015490565b60408051338152602081018e90527fd31325e5dc55b03edf08c70299d3b1bc8d4c2ca8512c90138ddd03e3f54fce6c910160405180910390a26105728a8787876109fb565b5050505050505050505050565b60018101805463ffffffff60801b191690556040517f943d5d24442f02461445e15c5d7d4a4ef0acb0d32c5d6f6af37a6882249912ff907f0635ad75fae4d4e8d896461a635d23700076a1c3fd8da26276f18cb1c09ea566906000805160206118ad8339815191529060008051602061188d833981519152906106049060009061172e565b60405180910390a160018401805463ffffffff60601b1963ffffffff4216600160401b02166fffffffffffffffff0000000000000000199091161763ffffffff60601b179055600061065582610b51565b9050610662836001015490565b6040518281527f6e3d05bc77b9307d9ba574c7c3196a746edd51104ded1c823edc63be4b8a63c39060200160405180910390a2600180840180549182018155600090815260209020018190556102fd84610c1a565b7f0635ad75fae4d4e8d896461a635d23700076a1c3fd8da26276f18cb1c09ea5675460018201546000917f0635ad75fae4d4e8d896461a635d23700076a1c3fd8da26276f18cb1c09ea566918390600160801b900463ffffffff166002811115610723576107236116fa565b90506000816002811115610739576107396116fa565b1461074e57610749826001611770565b610750565b815b95945050505050565b61076281610c3d565b50565b600061076f6116aa565b6107776116aa565b836107b25760405162461bcd60e51b815260206004820152600b60248201526a656d70747920636c61696d60a81b6044820152606401610228565b6107bc8686610c5c565b6107fd5760405162461bcd60e51b81526020600482015260126024820152711cd95b99195c881b9bdd08185b1b1bddd95960721b6044820152606401610228565b60006108098787610d0b565b600388015460405163cb9f881360e01b815291925073__$cf2fb72623b6ba225c3cfc459aec70b905$__9163cb9f881391610851918590600401918252602082015260400190565b602060405180830381865af415801561086e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108929190611788565b156108ef5760405162461bcd60e51b815260206004820152602760248201527f73656e6465722068616420636c61696d656420696e20746869732065706f6368604482015266206265666f726560c81b6064820152608401610228565b86546108f9578487555b865485146109595761094d600260405180604001604052808a6000015481526020018881525060405180604001604052806109338c610dea565b6001600160a01b0390811682528b16602090910152610f11565b935093509350506109f2565b6109638787610f6a565b61096c8761100c565b6109b0576040805180820182528681526000602080830182905283518085019094526001600160a01b038a16845283018190526109ab92909190610f11565b6109ea565b6040805180820182528681526000602080830182905283518085019094526001600160a01b038a1684528301526109ea9160019190610f11565b935093509350505b93509350939050565b6000836002811115610a0f57610a0f6116fa565b03610a99576001840154600090600160801b900463ffffffff166002811115610a3a57610a3a6116fa565b90506001816002811115610a5057610a506116fa565b14610a93576001858101805463ffffffff60801b1916600160801b17905560405160008051602061188d83398151915291610a8a9161172e565b60405180910390a15b50610b4b565b6001836002811115610aad57610aad6116fa565b03610ac057610abb8461057f565b610b4b565b6001840154600090600160801b900463ffffffff166002811115610ae657610ae66116fa565b90506002816002811115610afc57610afc6116fa565b14610b415760018501805463ffffffff60801b1916600160811b17905560405160008051602061188d83398151915290610b389060029061172e565b60405180910390a15b6102fd8383611104565b50505050565b6000610b5c8261112d565b81546000835560038301546040516367bdc85360e11b8152600481019190915273__$cf2fb72623b6ba225c3cfc459aec70b905$__9063cf7b90a690602401602060405180830381865af4158015610bb8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bdc91906117b1565b60038401556040518181527fddc860800a99149017c480ec51523bf4143b7215e78956ae5c31e5c568f5383a9060200160405180910390a192915050565b600381015415610c2f576107628160006116c8565b6107626001820160006116c8565b600381015415610c4e576000610c51565b60015b60ff16600390910155565b60006001600160a01b038216610ca05760405162461bcd60e51b815260206004820152600960248201526806164647265737320360bc1b6044820152606401610228565b60005b6001840154811015610cff57836001018181548110610cc457610cc46117ca565b6000918252602090912001546001600160a01b0390811690841603610ced576001915050610d05565b80610cf7816117e0565b915050610ca3565b50600090505b92915050565b60006001600160a01b038216610d4f5760405162461bcd60e51b815260206004820152600960248201526806164647265737320360bc1b6044820152606401610228565b60005b6001840154811015610dab57836001018181548110610d7357610d736117ca565b6000918252602090912001546001600160a01b0390811690841603610d99579050610d05565b80610da3816117e0565b915050610d52565b5060405162461bcd60e51b81526020600482015260136024820152721d985b1a59185d1bdc881b9bdd08199bdd5b99606a1b6044820152606401610228565b6003810154604051623ea57d60ea1b81526004810191909152600090819073__$cf2fb72623b6ba225c3cfc459aec70b905$__9063fa95f40090602401602060405180830381865af4158015610e44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e6891906117b1565b905060005b6001840154811015610ec8576001811b821615610eb657836001018181548110610e9957610e996117ca565b6000918252602090912001546001600160a01b0316949350505050565b80610ec0816117e0565b915050610e6d565b5060405162461bcd60e51b815260206004820152601c60248201527f4167726565696e672076616c696461746f72206e6f7420666f756e64000000006044820152606401610228565b6000610f1b6116aa565b610f236116aa565b7f495383aed97965c56495cdbadedfe9667a1b028c54d3fc4b5335895146e02b70868686604051610f56939291906117f9565b60405180910390a150939492935090919050565b6000610f768383610d0b565b600384015460405163335c20d760e21b815291925073__$cf2fb72623b6ba225c3cfc459aec70b905$__9163cd70835c91610fbe918590600401918252602082015260400190565b602060405180830381865af4158015610fdb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fff91906117b1565b8360030181905550505050565b6003810154604051636a02b7ff60e11b8152600481018290526000919073__$cf2fb72623b6ba225c3cfc459aec70b905$__9063d4056ffe90602401602060405180830381865af4158015611065573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061108991906117b1565b604051623ea57d60ea1b81526004810183905273__$cf2fb72623b6ba225c3cfc459aec70b905$__9063fa95f40090602401602060405180830381865af41580156110d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110fc91906117b1565b149392505050565b8051602082015183516000805160206118cd8339815191529261112892849261126a565b505050565b6003810154604051623ea57d60ea1b815260009173__$cf2fb72623b6ba225c3cfc459aec70b905$__9163fa95f4009161116d9160040190815260200190565b602060405180830381865af415801561118a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111ae91906117b1565b905060005b6001830154811015611128576001811b8216156112585760038301546040516314bc74ad60e21b81526004810191909152602481018290526001604482015273__$cf2fb72623b6ba225c3cfc459aec70b905$__906352f1d2b490606401602060405180830381865af415801561122e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061125291906117b1565b60038401555b80611262816117e0565b9150506111b3565b60006112746116aa565b61127c6116aa565b6000805160206118ad83398151915261129781888888611320565b60018b01805463ffffffff60601b1916600160601b4263ffffffff1602179055604080516001600160a01b03808d1682528b16602082015290810189905292965090945092507f2afbde4d47160a9c5de25b0df88d5b83e705286f2a447cac162db5e99ad6f5d29060600160405180910390a1611316888585856109fb565b5050505050505050565b600061132a6116aa565b6113326116aa565b61133c8786611545565b865484036113d65761134d8761100c565b611391576040805180820182528581526000602080830182905283518085019094526001600160a01b038a168452830181905261138c92909190611665565b6113cb565b6040805180820182528581526000602080830182905283518085019094526001600160a01b038a1684528301526113cb9160019190611665565b92509250925061153b565b6003870154604051623ea57d60ea1b8152600481019190915273__$cf2fb72623b6ba225c3cfc459aec70b905$__9063fa95f40090602401602060405180830381865af415801561142b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061144f91906117b1565b156114a0576113cb600260405180604001604052808a6000015481526020018781525060405180604001604052806114868c610dea565b6001600160a01b0390811682528b16602090910152611665565b8387556114ad8787610f6a565b6114b68761100c565b6114fa576040805180820182528581526000602080830182905283518085019094526001600160a01b038a16845283018190526114f592909190611665565b611534565b6040805180820182528581526000602080830182905283518085019094526001600160a01b038a1684528301526115349160019190611665565b9250925092505b9450945094915050565b60005b600183015481101561112857826001018181548110611569576115696117ca565b6000918252602090912001546001600160a01b039081169083160361165357600083600101828154811061159f5761159f6117ca565b600091825260209091200180546001600160a01b0319166001600160a01b03929092169190911790556003830154604051632b099ae360e21b815260048101919091526024810182905273__$cf2fb72623b6ba225c3cfc459aec70b905$__9063ac266b8c90604401602060405180830381865af4158015611625573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061164991906117b1565b6003840155505050565b8061165d816117e0565b915050611548565b600061166f6116aa565b6116776116aa565b7f09201c193a07cae1df95ae692cc698685574c942a04514c48a4c3249f38594ff868686604051610f56939291906117f9565b60405180604001604052806002906020820280368337509192915050565b508054600082559060005260206000209081019061076291905b808211156116f657600081556001016116e2565b5090565b634e487b7160e01b600052602160045260246000fd5b6003811061076257634e487b7160e01b600052602160045260246000fd5b6020810161173b83611710565b91905290565b60006020828403121561175357600080fd5b5035919050565b634e487b7160e01b600052601160045260246000fd5b600082198211156117835761178361175a565b500190565b60006020828403121561179a57600080fd5b815180151581146117aa57600080fd5b9392505050565b6000602082840312156117c357600080fd5b5051919050565b634e487b7160e01b600052603260045260246000fd5b6000600182016117f2576117f261175a565b5060010190565b60a0810161180685611710565b84825260208083018560005b600281101561182f57815183529183019190830190600101611812565b505050606083018460005b60028110156118605781516001600160a01b03168352918301919083019060010161183a565b5050505094935050505056fed32d7f90491bee81172a406b65f3270d810392fe53bb0379dde8bdd4e624189ded606d544c2202d032d2626c390923e6f260ca5d89625bba0cfe70d2bdda4e8f8ab37fef2b2e34c4b62ff9948ee661cdcf34e209d7c20f4d1f6e83085e93b1fcd32d7f90491bee81172a406b65f3270d810392fe53bb0379dde8bdd4e624189ca26469706673582212206ad80b2d7d7db0dbe765df1ce64bbb0b18ab0328debb5a025393620e1d30933564736f6c634300080d0033",
  "libraries": {
    "LibClaimsMask": "0xdfE71bbad0ce232131dcc9e42e131ADD57ff3998"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "claim(bytes32)": {
        "details": "ValidatorManager makes sure that msg.sender is allowed      and that claim != bytes32(0) TODO: add signatures for aggregated claims",
        "params": {
          "_epochHash": "hash of epoch"
        }
      },
      "finalizeEpoch()": {
        "details": "can only be called if challenge period is over"
      },
      "getCurrentEpoch()": {
        "details": "if phase is input accumulation, then the epoch number is length      of finalized epochs array, else there are two non finalized epochs,      one awaiting consensus/dispute and another accumulating input",
        "returns": {
          "_0": "index of current epoch"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "events": {
      "Claim(uint256,address,bytes32)": {
        "notice": "claim submitted"
      },
      "FinalizeEpoch(uint256,bytes32)": {
        "notice": "epoch finalized"
      },
      "PhaseChange(uint8)": {
        "notice": "phase change"
      },
      "ResolveDispute(address,address,bytes32)": {
        "notice": "dispute resolved"
      }
    },
    "kind": "user",
    "methods": {
      "claim(bytes32)": {
        "notice": "claim the result of current epoch"
      },
      "finalizeEpoch()": {
        "notice": "finalize epoch after timeout"
      },
      "getChallengePeriod()": {
        "notice": "returns the challenge period in seconds"
      },
      "getCurrentEpoch()": {
        "notice": "returns index of current (accumulating) epoch"
      },
      "getCurrentPhase()": {
        "notice": "returns the current phase"
      },
      "getInputAccumulationStart()": {
        "notice": "returns the input accumulation start timestamp"
      },
      "getInputDuration()": {
        "notice": "returns the input duration in seconds"
      },
      "getSealingEpochTimestamp()": {
        "notice": "returns the sealing epoch timestamp"
      },
      "getTemplateHash()": {
        "notice": "returns the machine's template hash"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}